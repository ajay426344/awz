---
- name: Phase 2 - Apply Patch with VM Management
  hosts: all
  gather_facts: no
  serial: 1
  vars:
    ansible_user: root
    ansible_password: "Ajay@426344"
    ansible_connection: ssh
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
    target_build: "24859861"
    initial_wait: 180  # 3 minutes initial wait
    ping_interval: 30   # Check every 30 seconds
    max_wait_time: 900  # 15 minutes total timeout
    vm_shutdown_timeout: 300  # 5 minutes for VM shutdown
    vm_state_file: "/tmp/vm_state.txt"
    dynatrace_url: "https://ofp39563.live.dynatrace.com"
    dynatrace_token: "dt0c01.MOQDVGYZV5NLQAAUFJMYVXM4.PNI42OD4D5V33H6IV4HQKJGB2VFDGJTPV3D6TKJBTMQ35JD62QIDNUM3OJKGQMVJ"
    
  tasks:
    - name: Phase 2 initialization
      block:
        - name: Set Phase 2 start time
          set_fact:
            phase2_start_time: "{{ now().strftime('%s') }}"
            
        - name: Send Phase 2 start event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_INFO"
              title: "ESXi Phase 2 Started - VM Management and Reboot"
              properties:
                host: "{{ inventory_hostname }}"
                phase: "phase2_start"
            status_code: [200, 201, 202]
          delegate_to: localhost
          vars:
            ansible_connection: local
          ignore_errors: yes
            
    - name: Pre-reboot checks
      block:
        - name: Get current build version
          raw: vmware -v | grep -o 'build-[0-9]*' | cut -d'-' -f2
          register: pre_reboot_build
          
        - name: Display current build
          debug:
            msg: "Current build: {{ pre_reboot_build.stdout | trim }}"
            
    - name: VM Management - Shutdown
      block:
        - name: Get list of powered-on VMs
          raw: |
            echo "=== Getting powered-on VMs ==="
            POWERED_VMS=""
            for VMID in $(vim-cmd vmsvc/getallvms | tail -n +2 | awk '{print $1}'); do
              STATE=$(vim-cmd vmsvc/power.getstate $VMID | tail -1)
              if echo "$STATE" | grep -q "Powered on"; then
                NAME=$(vim-cmd vmsvc/get.summary $VMID | grep -E "name = " | cut -d'"' -f2)
                echo "Found powered-on VM: $NAME (ID: $VMID)"
                POWERED_VMS="$POWERED_VMS $VMID"
              fi
            done
            echo "POWERED_ON_VMS:$POWERED_VMS"
          register: vm_list
          
        - name: Parse powered-on VMs
          set_fact:
            powered_on_vms: "{{ (vm_list.stdout | regex_search('POWERED_ON_VMS:(.*)$', '\\1') | first).split() if vm_list.stdout is search('POWERED_ON_VMS:') else [] }}"
            
        - name: Save VM state to file
          raw: |
            STATE_FILE="{{ vm_state_file }}"
            VM_IDS="{{ powered_on_vms | join(' ') }}"
            if [ ! -z "$VM_IDS" ]; then
              echo "Saving VM state to $STATE_FILE"
              > "$STATE_FILE"
              for VMID in $VM_IDS; do
                NAME=$(vim-cmd vmsvc/get.summary $VMID | grep -E "name = " | cut -d'"' -f2)
                echo "$VMID:$NAME" >> "$STATE_FILE"
              done
              echo "Saved $(echo $VM_IDS | wc -w) VM states"
              cat "$STATE_FILE"
            else
              echo "No VMs to save"
            fi
          when: powered_on_vms | length > 0
            
        - name: Display VM shutdown plan
          debug:
            msg: "VMs to shutdown: {{ powered_on_vms | length }} VMs"
          
        - name: Send VM shutdown event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_INFO"
              title: "Shutting down {{ powered_on_vms | length }} VMs"
              properties:
                host: "{{ inventory_hostname }}"
                vm_count: "{{ powered_on_vms | length }}"
                action: "vm_shutdown_start"
            status_code: [200, 201, 202]
          delegate_to: localhost
          vars:
            ansible_connection: local
          ignore_errors: yes
          when: powered_on_vms | length > 0
            
        - name: Gracefully shutdown all powered-on VMs
          raw: |
            echo "Shutting down VMs..."
            VM_IDS="{{ powered_on_vms | join(' ') }}"
            if [ ! -z "$VM_IDS" ]; then
              for VMID in $VM_IDS; do
                echo "Shutting down VM ID: $VMID"
                vim-cmd vmsvc/power.shutdown $VMID 2>/dev/null || vim-cmd vmsvc/power.off $VMID
              done
              
              # Wait for VMs to shutdown
              TIMEOUT={{ vm_shutdown_timeout }}
              ELAPSED=0
              while [ $ELAPSED -lt $TIMEOUT ]; do
                RUNNING=0
                for VMID in $VM_IDS; do
                  STATE=$(vim-cmd vmsvc/power.getstate $VMID | tail -1)
                  if echo "$STATE" | grep -q "Powered on"; then
                    RUNNING=$((RUNNING + 1))
                  fi
                done
                
                if [ $RUNNING -eq 0 ]; then
                  echo "All VMs shutdown successfully"
                  break
                fi
                
                echo "Waiting for $RUNNING VMs to shutdown..."
                sleep 10
                ELAPSED=$((ELAPSED + 10))
              done
            else
              echo "No VMs to shutdown"
            fi
          register: vm_shutdown
          when: powered_on_vms | length > 0
          
    - name: Enter maintenance mode
      block:
        - name: Check maintenance mode status
          raw: esxcli system maintenanceMode get
          register: mm_status
          
        - name: Enter maintenance mode if needed
          raw: |
            if echo "{{ mm_status.stdout }}" | grep -q "Disabled"; then
              echo "Enabling maintenance mode..."
              esxcli system maintenanceMode set --enable true
              echo "Maintenance mode enabled"
            else
              echo "Already in maintenance mode"
            fi
          register: mm_enable
          
    - name: Reboot host
      block:
        - name: Record reboot start time
          set_fact:
            reboot_start_time: "{{ now().strftime('%s') }}"
            
        - name: Send reboot event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_INFO"
              title: "ESXi Host Rebooting"
              properties:
                host: "{{ inventory_hostname }}"
                action: "reboot_initiated"
            status_code: [200, 201, 202]
          delegate_to: localhost
          vars:
            ansible_connection: local
          ignore_errors: yes
            
        - name: Issue reboot command
          raw: |
            echo "Issuing reboot command..."
            esxcli system shutdown reboot --delay=10 --reason=Patching
            echo "Reboot scheduled"
          ignore_errors: yes
          failed_when: false
          
        - name: Wait for host to go offline
          wait_for:
            host: "{{ ansible_host }}"
            port: 22
            state: stopped
            timeout: 120
          delegate_to: localhost
          vars:
            ansible_connection: local
          ignore_errors: yes
          
    - name: Wait for host recovery
      block:
        - name: Initial wait period (3 minutes)
          pause:
            seconds: "{{ initial_wait }}"
            prompt: "Waiting {{ initial_wait }} seconds for host to complete reboot..."
            
        - name: Start checking host availability
          block:
            - name: Display target host for debugging
              debug:
                msg: "Checking availability of host: {{ ansible_host | default(inventory_hostname) }}"
              delegate_to: localhost
              
            - name: Wait for host to respond to ping
              shell: |
                TARGET_HOST="{{ ansible_host | default(inventory_hostname) }}"
                echo "Pinging host: $TARGET_HOST"
                END_TIME=$(($(date +%s) + {{ max_wait_time - initial_wait }}))
                ATTEMPT=0
                while [ $(date +%s) -lt $END_TIME ]; do
                  ATTEMPT=$((ATTEMPT + 1))
                  if ping -c 1 -W 2 "$TARGET_HOST" > /dev/null 2>&1; then
                    echo "Host $TARGET_HOST is responding to ping (attempt $ATTEMPT)"
                    exit 0
                  fi
                  echo "Attempt $ATTEMPT: Host $TARGET_HOST not responding, waiting..."
                  sleep {{ ping_interval }}
                done
                echo "Timeout waiting for ping from $TARGET_HOST"
                exit 1
              delegate_to: localhost
              vars:
                ansible_connection: local
              register: ping_check
              
        - name: Wait for SSH to be available
          wait_for:
            host: "{{ ansible_host }}"
            port: 22
            state: started
            delay: 10
            timeout: 300
          delegate_to: localhost
          vars:
            ansible_connection: local
            
        - name: Wait for SSH to be fully ready
          wait_for_connection:
            timeout: 300
            delay: 10
            
    - name: Post-reboot tasks
      block:
        - name: Calculate downtime
          set_fact:
            downtime_seconds: "{{ (now().strftime('%s') | int) - (reboot_start_time | int) }}"
            
        - name: Get post-reboot build version
          raw: vmware -v | grep -o 'build-[0-9]*' | cut -d'-' -f2
          register: post_reboot_build
          retries: 3
          delay: 10
          until: post_reboot_build.rc == 0
          
        - name: Verify patch was applied
          set_fact:
            patch_applied: "{{ post_reboot_build.stdout | trim == target_build }}"
            
        - name: Display patch verification
          debug:
            msg:
              - "Pre-reboot build: {{ pre_reboot_build.stdout | trim }}"
              - "Post-reboot build: {{ post_reboot_build.stdout | trim }}"
              - "Target build: {{ target_build }}"
              - "Patch applied: {{ 'YES ✓' if patch_applied else 'NO ✗' }}"
              
    - name: Exit maintenance mode
      block:
        - name: Exit maintenance mode
          raw: |
            MM_STATUS=$(esxcli system maintenanceMode get)
            if echo "$MM_STATUS" | grep -q "Enabled"; then
              echo "Exiting maintenance mode..."
              esxcli system maintenanceMode set --enable false
              echo "Maintenance mode disabled"
            else
              echo "Already out of maintenance mode"
            fi
          register: mm_exit
          
    - name: VM Management - Power On
      block:
        - name: Check for saved VM state file
          raw: |
            STATE_FILE="{{ vm_state_file }}"
            if [ -f "$STATE_FILE" ]; then
              echo "Found saved VM state file at: $STATE_FILE"
              cat "$STATE_FILE"
            else
              echo "No saved VM state file at: $STATE_FILE"
            fi
          register: vm_state_check
          
        - name: Power on previously running VMs
          raw: |
            echo "Powering on VMs..."
            STATE_FILE="{{ vm_state_file }}"
            
            # Read VMs from persistent file
            if [ -f "$STATE_FILE" ]; then
              VM_IDS=$(cat "$STATE_FILE" | cut -d: -f1 | tr '\n' ' ')
              echo "Restoring VMs from: $STATE_FILE"
            else
              echo "No saved state file found at: $STATE_FILE"
              VM_IDS=""
            fi
            
            if [ ! -z "$VM_IDS" ]; then
              SUCCESS=0
              FAILED=0
              for VMID in $VM_IDS; do
                NAME=$(vim-cmd vmsvc/get.summary $VMID 2>/dev/null | grep -E "name = " | cut -d'"' -f2 || echo "VM-$VMID")
                echo "Starting VM: $NAME (ID: $VMID)"
                if vim-cmd vmsvc/power.on $VMID 2>/dev/null; then
                  SUCCESS=$((SUCCESS + 1))
                  echo "  Started successfully"
                else
                  FAILED=$((FAILED + 1))
                  echo "  Failed to start"
                fi
              done
              echo "SUMMARY: Started $SUCCESS VMs, Failed $FAILED"
              
              # Archive state file with timestamp
              if [ -f "$STATE_FILE" ]; then
                BACKUP_FILE="${STATE_FILE%.txt}_$(date +%Y%m%d_%H%M%S).bak"
                mv "$STATE_FILE" "$BACKUP_FILE"
                echo "Archived state file to: $BACKUP_FILE"
              fi
            else
              echo "No VMs to power on"
            fi
          register: vm_poweron
          
        - name: Verify VMs are running
          raw: |
            echo "Verifying VM status..."
            STATE_FILE="{{ vm_state_file }}"
            
            # Look for backup file if main file was moved
            if [ ! -f "$STATE_FILE" ]; then
              BACKUP_FILE=$(ls -t "${STATE_FILE%.txt}"*.bak 2>/dev/null | head -1)
              if [ -f "$BACKUP_FILE" ]; then
                VM_IDS=$(cat "$BACKUP_FILE" | cut -d: -f1 | tr '\n' ' ')
                echo "Using backup file: $BACKUP_FILE"
              else
                VM_IDS=""
              fi
            else
              VM_IDS=$(cat "$STATE_FILE" | cut -d: -f1 | tr '\n' ' ')
            fi
            
            if [ ! -z "$VM_IDS" ]; then
              sleep 30
              RUNNING=0
              STOPPED=0
              echo "=== VM Status Report ==="
              for VMID in $VM_IDS; do
                STATE=$(vim-cmd vmsvc/power.getstate $VMID 2>/dev/null | tail -1)
                NAME=$(vim-cmd vmsvc/get.summary $VMID 2>/dev/null | grep -E "name = " | cut -d'"' -f2 || echo "VM-$VMID")
                if echo "$STATE" | grep -q "Powered on"; then
                  echo "VM $NAME (ID: $VMID) is running"
                  RUNNING=$((RUNNING + 1))
                else
                  echo "VM $NAME (ID: $VMID) is not running"
                  STOPPED=$((STOPPED + 1))
                fi
              done
              echo "========================"
              echo "STATUS: $RUNNING running, $STOPPED stopped"
            fi
          register: vm_status
          
    - name: Final reporting
      block:
        - name: Calculate total duration
          set_fact:
            phase2_duration: "{{ (now().strftime('%s') | int) - (phase2_start_time | int) }}"
            
        - name: Send completion metrics to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "text/plain; charset=utf-8"
            body: |
              esxi.patch.phase2.success,host={{ inventory_hostname }} {{ 1 if patch_applied else 0 }} {{ now().strftime('%s') }}
              esxi.patch.phase2.downtime,host={{ inventory_hostname }} {{ downtime_seconds }} {{ now().strftime('%s') }}
              esxi.patch.phase2.duration,host={{ inventory_hostname }} {{ phase2_duration }} {{ now().strftime('%s') }}
              esxi.patch.phase2.vm_count,host={{ inventory_hostname }} {{ powered_on_vms | length }} {{ now().strftime('%s') }}
            status_code: [200, 201, 202, 204]
          delegate_to: localhost
          vars:
            ansible_connection: local
          ignore_errors: yes
          
        - name: Display final results
          debug:
            msg:
              - "========================================"
              - "PHASE 2 COMPLETE"
              - "========================================"
              - "Patch Status: {{ 'SUCCESS ✓' if patch_applied else 'FAILED ✗' }}"
              - "Build: {{ pre_reboot_build.stdout | trim }} → {{ post_reboot_build.stdout | trim }}"
              - "Target: {{ target_build }}"
              - "Downtime: {{ downtime_seconds }} seconds"
              - "Total Duration: {{ phase2_duration }} seconds"
              - "VMs Managed: {{ powered_on_vms | length }}"
              - "========================================"
              
        - name: Fail if patch not applied
          fail:
            msg: "Patch not applied! Current build {{ post_reboot_build.stdout | trim }} != {{ target_build }}"
          when: not patch_applied
