---
- name: Phase 1 - ESXi Patch Staging (Simplified HTTP Download)
  hosts: all
  gather_facts: no
  vars:
    ansible_user: root
    ansible_password: "Ajay@426344"
    ansible_connection: ssh
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
    patch_file: "VMware-ESXi-8.0U3g-24859861-depot.zip"
    patch_profile: "ESXi-8.0U3g-24859861-standard"
    http_server_url: "http://192.168.0.110:8080"
    target_build: "24859861"
    dynatrace_url: "https://ofp39563.live.dynatrace.com"
    dynatrace_token: "dt0c01.MOQDVGYZV5NLQAAUFJMYVXM4.PNI42OD4D5V33H6IV4HQKJGB2VFDGJTPV3D6TKJBTMQ35JD62QIDNUM3OJKGQMVJ"
    skip_connectivity_test: true  # Set to false to enable connectivity test
    
  tasks:
    - name: Set timestamps
      set_fact:
        phase1_start_time: "{{ now().strftime('%s') }}"
        
    - name: Send Phase 1 start event to Dynatrace
      uri:
        url: "{{ dynatrace_url }}/api/v2/events/ingest"
        method: POST
        headers:
          Authorization: "Api-Token {{ dynatrace_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          eventType: "CUSTOM_INFO"
          title: "ESXi Phase 1 Staging Started"
          properties:
            host: "{{ inventory_hostname }}"
            phase: "phase1_staging"
            patch_file: "{{ patch_file }}"
            target_build: "{{ target_build }}"
            severity: "INFO"
        status_code: [200, 201, 202]
      delegate_to: localhost
      ignore_errors: yes
      
    - name: Check if patch needed
      set_fact:
        needs_patching: "{{ hostvars[inventory_hostname]['host_current_build']|default('0')|int < target_build|int }}"
        
    - name: Execute staging process
      when: needs_patching
      block:
        - name: Create patches directory
          raw: mkdir -p {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches
          
        - name: Check if patch file already exists
          raw: |
            if [ -f "{{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }}" ]; then
              echo "EXISTS"
              ls -lh {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }}
            else
              echo "NOT_FOUND"
            fi
          register: patch_exists
          
        - name: Display patch status
          debug:
            msg: "Patch file status: {{ 'Already exists' if 'EXISTS' in patch_exists.stdout else 'Need to download' }}"
            
        - name: Download patch from HTTP server
          when: "'NOT_FOUND' in patch_exists.stdout"
          block:
            - name: Download patch file (Direct approach for ESXi)
              raw: |
                cd {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches
                
                # ESXi uses busybox wget which has limited options
                # Using simple wget without fancy options
                echo "Starting download from {{ http_server_url }}/{{ patch_file }}"
                
                # Download with basic wget (ESXi compatible)
                wget -O {{ patch_file }}.tmp "{{ http_server_url }}/{{ patch_file }}" 2>&1
                
                if [ $? -eq 0 ]; then
                  mv {{ patch_file }}.tmp {{ patch_file }}
                  echo "Download completed successfully"
                  ls -lh {{ patch_file }}
                else
                  rm -f {{ patch_file }}.tmp
                  echo "Download failed"
                  exit 1
                fi
              register: download_result
              retries: 3
              delay: 30
              until: download_result.rc == 0
              
            - name: Show download result
              debug:
                msg: "Download result: {{ download_result.stdout_lines[-3:] }}"
                
        - name: Verify patch file exists and is valid
          raw: |
            FILE="{{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }}"
            if [ -f "$FILE" ]; then
              SIZE=$(ls -l "$FILE" | awk '{print $5}')
              echo "File exists: $FILE"
              echo "Size: $SIZE bytes"
              if [ $SIZE -gt 1000000 ]; then
                echo "VALID"
              else
                echo "File too small, possibly corrupt"
                exit 1
              fi
            else
              echo "File not found: $FILE"
              exit 1
            fi
          register: verify_result
          
        - name: Perform dry-run
          raw: |
            esxcli software profile update \
              -d {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }} \
              -p {{ patch_profile }} \
              --dry-run
          register: dry_run_result
          ignore_errors: yes
          
        - name: Display dry-run results
          debug:
            msg: 
              - "Dry-run return code: {{ dry_run_result.rc }}"
              - "Output: {{ dry_run_result.stdout_lines[:10] if dry_run_result.stdout_lines is defined else 'No output' }}"
              
        - name: Stage patch with no-live-install
          raw: |
            esxcli software profile update \
              -d {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }} \
              -p {{ patch_profile }} \
              --no-live-install
          register: staging_result
          
        - name: Display staging results
          debug:
            msg:
              - "Staging completed"
              - "{{ staging_result.stdout_lines[:20] if staging_result.stdout_lines is defined else staging_result.stdout }}"
              
        - name: Validate staging success
          set_fact:
            staging_success: "{{ 'The update completed successfully' in staging_result.stdout or 'successfully' in staging_result.stdout|lower }}"
            reboot_required: "{{ 'Reboot Required: true' in staging_result.stdout }}"
            
        - name: Send completion event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_INFO"
              title: "ESXi Phase 1 {{ 'Completed' if staging_success else 'Failed' }}"
              properties:
                host: "{{ inventory_hostname }}"
                phase: "phase1_staging"
                status: "{{ 'success' if staging_success else 'failed' }}"
                reboot_required: "{{ reboot_required }}"
                severity: "{{ 'INFO' if staging_success else 'ERROR' }}"
            status_code: [200, 201, 202]
          delegate_to: localhost
          ignore_errors: yes
          
      rescue:
        - name: Handle failures
          debug:
            msg: 
              - "Task failed: {{ ansible_failed_task.name|default('Unknown task') }}"
              - "Error: {{ ansible_failed_result.msg|default('No error message') }}"
              
        - name: Cleanup on failure
          raw: |
            rm -f {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }}.tmp 2>/dev/null || true
          ignore_errors: yes
