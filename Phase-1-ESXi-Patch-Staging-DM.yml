---
- name: Phase 1 - ESXi Patch Staging with HTTP Port 80 (Fixed)
  hosts: all
  gather_facts: no
  vars:
    ansible_user: root
    ansible_password: "Ajay@426344"
    ansible_connection: ssh
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
    
    # Patch configuration
    patch_file: "VMware-ESXi-8.0U3g-24859861-depot.zip"
    patch_profile: "ESXi-8.0U3g-24859861-standard"
    target_build: "24859861"
    
    # HTTP server configuration - Using Port 80
    http_server_url: "http://192.168.0.110"
    
    # Dynatrace configuration
    dynatrace_url: "https://ofp39563.live.dynatrace.com"
    dynatrace_token: "dt0c01.MOQDVGYZV5NLQAAUFJMYVXM4.PNI42OD4D5V33H6IV4HQKJGB2VFDGJTPV3D6TKJBTMQ35JD62QIDNUM3OJKGQMVJ"
    enable_dynatrace: true
    
  tasks:
    - name: Phase 1 Start
      block:
        - name: Set start timestamp
          set_fact:
            phase1_start_time: "{{ now().strftime('%s') }}"
            phase1_start_iso: "{{ now().isoformat() }}"
            
        - name: Display phase information
          debug:
            msg:
              - "========================================"
              - "ESXi PATCH PHASE 1 - STAGING"
              - "========================================"
              - "Host: {{ inventory_hostname }}"
              - "HTTP Server: {{ http_server_url }}"
              - "Patch File: {{ patch_file }}"
              - "Target Build: {{ target_build }}"
              - "Started: {{ phase1_start_iso }}"
              
    - name: Pre-flight checks
      block:
        - name: Get ESXi version info
          raw: vmware -vl
          register: esxi_version
          
        - name: Display ESXi version
          debug:
            msg: "Current ESXi: {{ esxi_version.stdout_lines[0] if esxi_version.stdout_lines else 'Unknown' }}"
            
        - name: Check current build number
          set_fact:
            current_build: "{{ hostvars[inventory_hostname]['host_current_build']|default('0') }}"
            needs_patching: "{{ hostvars[inventory_hostname]['host_current_build']|default('0')|int < target_build|int }}"
            
        - name: Display patching decision
          debug:
            msg:
              - "Current Build: {{ current_build }}"
              - "Target Build: {{ target_build }}"
              - "Needs Patching: {{ 'YES' if needs_patching else 'NO - Already up to date' }}"
              
    - name: Main patching process
      when: needs_patching
      block:
        - name: Find datastore with sufficient space
          raw: |
            echo "Checking datastores for available space (need 3GB+)..."
            SELECTED_DS=""
            SELECTED_FREE=0
            
            for DS in $(esxcli storage filesystem list | grep VMFS | awk '{print $1}'); do
              FREE_BYTES=$(df -B 1 "$DS" 2>/dev/null | tail -1 | awk '{print $4}')
              FREE_GB=$((FREE_BYTES / 1024 / 1024 / 1024))
              
              echo "Datastore: $DS - Free: ${FREE_GB}GB"
              
              if [ $FREE_GB -gt 3 ] && [ $FREE_GB -gt $SELECTED_FREE ]; then
                SELECTED_DS="$DS"
                SELECTED_FREE=$FREE_GB
              fi
            done
            
            if [ -z "$SELECTED_DS" ]; then
              echo "ERROR: No datastore has 3GB+ free space"
              exit 1
            else
              echo "SELECTED_DATASTORE: $SELECTED_DS"
              echo "SELECTED_FREE_GB: $SELECTED_FREE"
            fi
          register: datastore_check
          failed_when: "'ERROR: No datastore' in datastore_check.stdout"
          
        - name: Parse selected datastore
          set_fact:
            datastore_path: "{{ datastore_check.stdout | regex_search('SELECTED_DATASTORE: (.+)', '\\1') | first }}"
            datastore_free_gb: "{{ datastore_check.stdout | regex_search('SELECTED_FREE_GB: (\\d+)', '\\1') | first }}"
            
        - name: Display selected datastore
          debug:
            msg:
              - "Selected Datastore: {{ datastore_path }}"
              - "Available Space: {{ datastore_free_gb }}GB"
              
        - name: Create patches directory
          raw: |
            mkdir -p "{{ datastore_path }}/patches"
            echo "Created directory: {{ datastore_path }}/patches"
          register: dir_created
          
        - name: Set patch paths
          set_fact:
            patch_full_path: "{{ datastore_path }}/patches/{{ patch_file }}"
            
        - name: Check if patch already exists
          raw: |
            if [ -f "{{ patch_full_path }}" ]; then
              SIZE=$(ls -l "{{ patch_full_path }}" | awk '{print $5}')
              echo "STATUS: EXISTS"
              echo "SIZE: $SIZE"
              if [ $SIZE -gt 900000000 ]; then
                echo "VALID: YES"
              else
                echo "VALID: NO"
                rm -f "{{ patch_full_path }}"
              fi
            else
              echo "STATUS: NOT_FOUND"
            fi
          register: patch_check
          
        - name: Display patch status
          debug:
            msg: "{{ patch_check.stdout_lines }}"
            
        - name: Download patch if needed
          when: "'NOT_FOUND' in patch_check.stdout or 'VALID: NO' in patch_check.stdout"
          block:
            - name: Enable HTTP client firewall
              raw: |
                esxcli network firewall ruleset set -e true -r httpClient
                echo "httpClient firewall rule enabled"
                
            - name: Download patch from HTTP server
              raw: |
                cd "{{ datastore_path }}/patches"
                echo "Downloading: {{ http_server_url }}/{{ patch_file }}"
                wget -O "{{ patch_file }}.tmp" "{{ http_server_url }}/{{ patch_file }}"
                if [ $? -eq 0 ]; then
                  mv "{{ patch_file }}.tmp" "{{ patch_file }}"
                  echo "DOWNLOAD: SUCCESS"
                  ls -lh "{{ patch_file }}"
                else
                  rm -f "{{ patch_file }}.tmp"
                  echo "DOWNLOAD: FAILED"
                  exit 1
                fi
              register: download_result
              retries: 3
              delay: 30
              until: download_result.rc == 0
              
        - name: Verify patch file
          raw: |
            if [ -f "{{ patch_full_path }}" ]; then
              SIZE=$(ls -l "{{ patch_full_path }}" | awk '{print $5}')
              echo "File: {{ patch_full_path }}"
              echo "Size: $SIZE bytes"
              if [ $SIZE -gt 900000000 ]; then
                echo "VALIDATION: PASSED"
              else
                echo "VALIDATION: FAILED"
                exit 1
              fi
            else
              echo "File not found!"
              exit 1
            fi
          register: validation
          
        - name: Display validation
          debug:
            msg: "{{ validation.stdout_lines }}"
            
        # Fixed esxcli commands - using shell escaping properly
        - name: Run dry-run test
          raw: |
            echo "Running dry-run test..."
            /bin/esxcli software profile update \
              -d {{ patch_full_path }} \
              -p {{ patch_profile }} \
              --dry-run
          register: dry_run
          ignore_errors: yes
          
        - name: Check dry-run output
          debug:
            msg:
              - "Dry-run RC: {{ dry_run.rc }}"
              - "Output: {{ dry_run.stdout_lines[:30] if dry_run.stdout_lines else dry_run.stdout }}"
              
        # If dry-run fails, try alternative approach
        - name: Alternative - List profiles and retry
          when: dry_run.rc != 0
          block:
            - name: List available profiles
              raw: |
                echo "Listing profiles in depot..."
                /bin/esxcli software sources profile list \
                  -d {{ patch_full_path }} | grep ESXi
              register: profiles
              
            - name: Display profiles
              debug:
                msg: "{{ profiles.stdout_lines }}"
                
            - name: Retry dry-run with explicit path
              raw: |
                echo "Retrying with full esxcli path..."
                /usr/lib/vmware/esxcli software profile update \
                  --depot={{ patch_full_path }} \
                  --profile={{ patch_profile }} \
                  --dry-run
              register: dry_run_retry
              ignore_errors: yes
              
            - name: Set dry-run result
              set_fact:
                dry_run_success: "{{ dry_run_retry.rc == 0 }}"
              when: dry_run_retry is defined
              
        - name: Stage patch with no-live-install
          raw: |
            echo "Staging patch..."
            /bin/esxcli software profile update \
              -d {{ patch_full_path }} \
              -p {{ patch_profile }} \
              --no-live-install
          register: staging_result
          when: dry_run.rc == 0 or (dry_run_retry is defined and dry_run_retry.rc == 0)
          
        - name: Parse staging results
          set_fact:
            staging_success: "{{ staging_result.rc == 0 }}"
            reboot_required: "{{ 'Reboot Required: true' in staging_result.stdout }}"
            phase1_duration: "{{ (now().strftime('%s')|int) - (phase1_start_time|int) }}"
          when: staging_result is defined
          
        - name: Display final results
          debug:
            msg:
              - "========================================"
              - "PHASE 1 RESULTS"
              - "========================================"
              - "Staging: {{ 'SUCCESS' if (staging_result is defined and staging_result.rc == 0) else 'FAILED' }}"
              - "Reboot Required: {{ reboot_required|default('Unknown') }}"
              - "Duration: {{ phase1_duration|default('N/A') }} seconds"
              
      rescue:
        - name: Handle failure
          debug:
            msg:
              - "PHASE 1 FAILED"
              - "Task: {{ ansible_failed_task.name|default('Unknown') }}"
              - "Error: {{ ansible_failed_result.msg|default('Check logs') }}"
              
        - name: Manual instructions
          debug:
            msg:
              - "========================================"
              - "MANUAL FIX INSTRUCTIONS"
              - "========================================"
              - "SSH to ESXi host and run:"
              - ""
              - "1. Check file exists:"
              - "   ls -la {{ patch_full_path|default('/vmfs/volumes/datastore1/patches/' + patch_file) }}"
              - ""
              - "2. Run dry-run manually:"
              - "   esxcli software profile update -d {{ patch_full_path|default('/vmfs/volumes/datastore1/patches/' + patch_file) }} -p {{ patch_profile }} --dry-run"
              - ""
              - "3. If dry-run works, stage:"
              - "   esxcli software profile update -d {{ patch_full_path|default('/vmfs/volumes/datastore1/patches/' + patch_file) }} -p {{ patch_profile }} --no-live-install"
              - ""
              - "4. Reboot when ready:"
              - "   reboot"
