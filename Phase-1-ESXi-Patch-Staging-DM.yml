---
- name: Phase 1 - ESXi Patch Staging with Dynatrace Monitoring
  hosts: all
  gather_facts: no
  vars:
    ansible_user: root
    ansible_password: "Ajay@426344"
    ansible_connection: ssh
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
    patch_file: "VMware-ESXi-8.0U3g-24859861-depot.zip"
    patch_profile: "ESXi-8.0U3g-24859861-standard"
    patch_source: "/mnt/patches"
    target_build: "24859861"
    dynatrace_url: "https://ofp39563.live.dynatrace.com"
    dynatrace_token: "dt0c01.MOQDVGYZV5NLQAAUFJMYVXM4.PNI42OD4D5V33H6IV4HQKJGB2VFDGJTPV3D6TKJBTMQ35JD62QIDNUM3OJKGQMVJ"
    # Upload timeout in seconds (120 minutes)
    patch_upload_timeout_seconds: 7200

  tasks:
    - name: Ensure controller has required CLI tools (scp, ssh)
      delegate_to: localhost
      vars:
        ansible_connection: local
      block:
        - name: Check scp exists on controller
          command: which scp
          register: scp_check
          failed_when: scp_check.rc != 0
        - name: Check ssh exists on controller
          command: which ssh
          register: ssh_check
          failed_when: ssh_check.rc != 0

    - name: Set timestamps
      set_fact:
        current_epoch: "{{ now().strftime('%s') }}"
        current_iso: "{{ now().isoformat() }}"
      run_once: true

    - name: Record phase 1 start time
      set_fact:
        phase1_start_time: "{{ current_epoch }}"

    - name: Send Phase 1 start event to Dynatrace
      uri:
        url: "{{ dynatrace_url }}/api/v2/events/ingest"
        method: POST
        headers:
          Authorization: "Api-Token {{ dynatrace_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          eventType: "CUSTOM_INFO"
          title: "ESXi Phase 1 Staging Started"
          properties:
            host: "{{ inventory_hostname }}"
            phase: "phase1_staging"
            patch_file: "{{ patch_file }}"
            target_build: "{{ target_build }}"
            severity: "INFO"
        status_code: [200, 201, 202]
      delegate_to: localhost
      vars:
        ansible_connection: local

    - name: Check if patch needed
      set_fact:
        needs_patching: "{{ hostvars[inventory_hostname]['host_current_build']|default('0')|int < target_build|int }}"

    - name: Send eligibility metric to Dynatrace
      uri:
        url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
        method: POST
        headers:
          Authorization: "Api-Token {{ dynatrace_token }}"
          Content-Type: "text/plain; charset=utf-8"
        body: |
          esxi.patch.phase1.eligibility,host={{ inventory_hostname }} {{ 1 if needs_patching else 0 }} {{ phase1_start_time }}
        status_code: [200, 201, 202, 204]
      delegate_to: localhost
      vars:
        ansible_connection: local

    - name: Execute staging process
      when: needs_patching
      block:
        - name: Create patches directory
          raw: mkdir -p {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches

        - name: Check if patch file exists
          raw: ls -lh {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }} 2>/dev/null || echo "NOT_FOUND"
          register: patch_exists

        - name: Record upload start time
          set_fact:
            upload_start: "{{ now().strftime('%s') }}"
          when: "'NOT_FOUND' in patch_exists.stdout"

        - name: Upload patch using scp (controller -> ESXi) with 120 minute timeout (run locally)
          delegate_to: localhost
          vars:
            dest_ds: "{{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches"
          vars:
            ansible_connection: local
          raw: |
            # run on the controller (local) so it does not attempt SSH to localhost
            # using plain scp (no sshpass) â€” controller must authenticate to ESXi via key/agent
            timeout {{ patch_upload_timeout_seconds }} scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
              "{{ patch_source }}/{{ patch_file }}" \
              "root@{{ inventory_hostname }}:{{ dest_ds }}/{{ patch_file }}"
          when: "'NOT_FOUND' in patch_exists.stdout"
          register: rsync_result
          changed_when: rsync_result.rc == 0
          failed_when: rsync_result.rc != 0

        - name: Send Dynatrace metric if upload timed out (exit code 124)
          when:
            - "'NOT_FOUND' in patch_exists.stdout"
            - rsync_result is defined
            - rsync_result.rc == 124
          uri:
            url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "text/plain; charset=utf-8"
            body: |
              esxi.patch.phase1.upload_timeout,host={{ inventory_hostname }} 1 {{ now().strftime('%s') }}
            status_code: [200, 201, 202, 204]
          delegate_to: localhost
          vars:
            ansible_connection: local

        - name: Send Dynatrace event and metric if upload failed for any other reason
          when:
            - "'NOT_FOUND' in patch_exists.stdout"
            - rsync_result is defined
            - rsync_result.rc != 0
          block:
            - name: Send upload failure metric
              uri:
                url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
                method: POST
                headers:
                  Authorization: "Api-Token {{ dynatrace_token }}"
                  Content-Type: "text/plain; charset=utf-8"
                body: |
                  esxi.patch.phase1.upload_success,host={{ inventory_hostname }} 0 {{ now().strftime('%s') }}
                status_code: [200, 201, 202, 204]
              delegate_to: localhost
              vars:
                ansible_connection: local

            - name: Send upload failure event with reason to Dynatrace
              uri:
                url: "{{ dynatrace_url }}/api/v2/events/ingest"
                method: POST
                headers:
                  Authorization: "Api-Token {{ dynatrace_token }}"
                  Content-Type: "application/json"
                body_format: json
                body:
                  eventType: "CUSTOM_ALERT"
                  title: "ESXi Phase 1 Upload Failed"
                  properties:
                    host: "{{ inventory_hostname }}"
                    phase: "phase1_staging"
                    patch_file: "{{ patch_file }}"
                    rc: "{{ rsync_result.rc }}"
                    stderr: "{{ rsync_result.stderr | default('') }}"
                    stdout: "{{ rsync_result.stdout | default('') }}"
                    severity: "ERROR"
                status_code: [200, 201, 202]
              delegate_to: localhost
              vars:
                ansible_connection: local

        - name: Calculate upload duration and send to Dynatrace
          when:
            - "'NOT_FOUND' in patch_exists.stdout"
            - rsync_result is defined
            - rsync_result.rc == 0
          block:
            - set_fact:
                upload_duration: "{{ (now().strftime('%s') | int) - (upload_start | int) }}"
            - uri:
                url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
                method: POST
                headers:
                  Authorization: "Api-Token {{ dynatrace_token }}"
                  Content-Type: "text/plain; charset=utf-8"
                body: |
                  esxi.patch.phase1.upload_duration_seconds,host={{ inventory_hostname }} {{ upload_duration }} {{ now().strftime('%s') }}
                status_code: [200, 201, 202, 204]
              delegate_to: localhost
              vars:
                ansible_connection: local

        - name: Perform dry-run
          raw: |
            esxcli software profile update \
              -d {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }} \
              -p {{ patch_profile }} \
              --dry-run
          register: dry_run_result

        - name: Send dry-run status to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "text/plain; charset=utf-8"
            body: |
              esxi.patch.phase1.dryrun_status,host={{ inventory_hostname }} {{ 1 if dry_run_result.rc == 0 else 0 }} {{ now().strftime('%s') }}
            status_code: [200, 201, 202, 204]
          delegate_to: localhost
          vars:
            ansible_connection: local

        - name: Stage patch with no-live-install
          raw: |
            esxcli software profile update \
              -d {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }} \
              -p {{ patch_profile }} \
              --no-live-install
          register: staging_result

        - name: Validate staging success
          set_fact:
            staging_success: "{{ 'The update completed successfully' in staging_result.stdout }}"
            reboot_required: "{{ 'Reboot Required: true' in staging_result.stdout }}"
            phase1_duration: "{{ (now().strftime('%s') | int) - (phase1_start_time | int) }}"

        - name: Send Phase 1 completion metrics to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "text/plain; charset=utf-8"
            body: |
              esxi.patch.phase1.staging_status,host={{ inventory_hostname }} {{ 1 if staging_success else 0 }} {{ now().strftime('%s') }}
              esxi.patch.phase1.reboot_required,host={{ inventory_hostname }} {{ 1 if reboot_required else 0 }} {{ now().strftime('%s') }}
              esxi.patch.phase1.duration_seconds,host={{ inventory_hostname }} {{ phase1_duration }} {{ now().strftime('%s') }}
            status_code: [200, 201, 202, 204]
          delegate_to: localhost
          vars:
            ansible_connection: local

        - name: Send Phase 1 completion event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_INFO"
              title: "ESXi Phase 1 {{ 'Completed' if staging_success else 'Failed' }}"
              properties:
                host: "{{ inventory_hostname }}"
                phase: "phase1_staging"
                status: "{{ 'success' if staging_success else 'failed' }}"
                duration_seconds: "{{ phase1_duration }}"
                reboot_required: "{{ reboot_required }}"
                severity: "{{ 'INFO' if staging_success else 'ERROR' }}"
            status_code: [200, 201, 202]
          delegate_to: localhost
          vars:
            ansible_connection: local

    - name: Send skip notification if patch not needed
      uri:
        url: "{{ dynatrace_url }}/api/v2/events/ingest"
        method: POST
        headers:
          Authorization: "Api-Token {{ dynatrace_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          eventType: "CUSTOM_INFO"
          title: "ESXi Phase 1 Skipped - Already Updated"
          properties:
            host: "{{ inventory_hostname }}"
            phase: "phase1_staging"
            status: "skipped"
            current_build: "{{ hostvars[inventory_hostname]['host_current_build']|default('unknown') }}"
            target_build: "{{ target_build }}"
            severity: "INFO"
        status_code: [200, 201, 202]
      delegate_to: localhost
      vars:
        ansible_connection: local
      when: not needs_patching
