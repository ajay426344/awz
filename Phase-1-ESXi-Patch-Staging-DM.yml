---
- name: Phase 1 - ESXi Patch Staging
  hosts: all
  gather_facts: no
  vars:
    ansible_user: root
    ansible_password: "Ajay@426344"
    ansible_connection: ssh
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
    
    # Patch configuration
    patch_file: "VMware-ESXi-8.0U3g-24859861-depot.zip"
    patch_profile: "ESXi-8.0U3g-24859861-standard"
    target_build: "24859861"
    http_server_url: "http://192.168.0.110"
    minimum_space_gb: 3
    
    # Dynatrace configuration
    dynatrace_url: "https://ofp39563.live.dynatrace.com"
    dynatrace_token: "dt0c01.MOQDVGYZV5NLQAAUFJMYVXM4.PNI42OD4D5V33H6IV4HQKJGB2VFDGJTPV3D6TKJBTMQ35JD62QIDNUM3OJKGQMVJ"
    
  tasks:
    - name: Set start timestamp
      set_fact:
        phase1_start_time: "{{ now().strftime('%s') }}"
        
    - name: Send start event to Dynatrace
      uri:
        url: "{{ dynatrace_url }}/api/v2/events/ingest"
        method: POST
        headers:
          Authorization: "Api-Token {{ dynatrace_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          eventType: "CUSTOM_INFO"
          title: "ESXi Phase 1 Staging Started"
          properties:
            host: "{{ inventory_hostname }}"
            patch_file: "{{ patch_file }}"
            target_build: "{{ target_build }}"
        status_code: [200, 201, 202]
      delegate_to: localhost
      vars:
        ansible_connection: local
        ansible_python_interpreter: "{{ ansible_playbook_python }}"
      ignore_errors: yes
      
    - name: Check current ESXi build
      raw: vmware -vl
      register: esxi_version
      
    - name: Determine if patching needed
      set_fact:
        needs_patching: "{{ hostvars[inventory_hostname]['host_current_build']|default('0')|int < target_build|int }}"
        
    - name: Display patching decision
      debug:
        msg: "Needs Patching: {{ 'YES' if needs_patching else 'NO' }}"
        
    - name: Main patching process
      when: needs_patching
      block:
        - name: Find best datastore with minimum space
          raw: |
            SELECTED_DS=""
            SELECTED_FREE=0
            MIN_SPACE_GB=3
            
            # Check all datastores
            for DS in /vmfs/volumes/datastore* /vmfs/volumes/[0-9a-f]*; do
              if [ -d "$DS" ] && [ ! -L "$DS" ]; then
                # Get free space in bytes first, then convert to GB
                FREE_BYTES=$(df -B 1 "$DS" 2>/dev/null | tail -1 | awk '{print $4}')
                if [ ! -z "$FREE_BYTES" ] && [ "$FREE_BYTES" -gt 0 ]; then
                  # Convert bytes to GB
                  FREE_GB=$((FREE_BYTES / 1024 / 1024 / 1024))
                  
                  # Show the datastore info
                  echo "Checking $DS: ${FREE_GB}GB free"
                  
                  # Select if has enough space and is the best so far
                  if [ "$FREE_GB" -ge "$MIN_SPACE_GB" ] && [ "$FREE_GB" -gt "$SELECTED_FREE" ]; then
                    SELECTED_DS="$DS"
                    SELECTED_FREE=$FREE_GB
                  fi
                fi
              fi
            done
            
            if [ -z "$SELECTED_DS" ]; then
              # If no datastore found, show what's available
              echo "ERROR: No datastore with ${MIN_SPACE_GB}GB free"
              echo "Available datastores:"
              df -h /vmfs/volumes/* 2>/dev/null | grep -v "^Filesystem"
              exit 1
            fi
            
            echo "SELECTED:$SELECTED_DS:$SELECTED_FREE"
          register: datastore_check
          failed_when: datastore_check.rc != 0
          
        - name: Parse datastore selection
          set_fact:
            datastore_path: "{{ datastore_check.stdout.split(':')[1] }}"
            patch_path: "{{ datastore_check.stdout.split(':')[1] }}/patches/{{ patch_file }}"
            
        - name: Create patches directory
          raw: mkdir -p "{{ datastore_path }}/patches"
          
        - name: Check if patch exists
          raw: |
            if [ -f "{{ patch_path }}" ]; then
              SIZE=$(ls -l "{{ patch_path }}" | awk '{print $5}')
              if [ $SIZE -gt 900000000 ]; then
                echo "EXISTS_VALID"
              else
                rm -f "{{ patch_path }}"
                echo "NEED_DOWNLOAD"
              fi
            else
              echo "NEED_DOWNLOAD"
            fi
          register: patch_status
          
        - name: Download patch if needed
          when: "'NEED_DOWNLOAD' in patch_status.stdout"
          block:
            - name: Enable HTTP firewall rule
              raw: esxcli network firewall ruleset set -e true -r httpClient
              
            - name: Download patch
              raw: |
                cd "{{ datastore_path }}/patches"
                wget -O "{{ patch_file }}.tmp" "{{ http_server_url }}/{{ patch_file }}"
                mv "{{ patch_file }}.tmp" "{{ patch_file }}"
              retries: 3
              delay: 30
              until: result.rc == 0
              register: result
              
        - name: Run dry-run test
          raw: |
            esxcli software profile update \
              -d "{{ patch_path }}" \
              -p "{{ patch_profile }}" \
              --dry-run
          register: dry_run
          ignore_errors: yes
          
        - name: Stage patch if dry-run succeeded
          raw: |
            esxcli software profile update \
              -d "{{ patch_path }}" \
              -p "{{ patch_profile }}" \
              --no-live-install
          register: staging
          when: dry_run.rc == 0
          
        - name: Calculate duration
          set_fact:
            duration: "{{ (now().strftime('%s')|int) - (phase1_start_time|int) }}"
            
        - name: Send completion metrics to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "text/plain; charset=utf-8"
            body: |
              esxi.patch.phase1.status,host={{ inventory_hostname }} {{ 1 if staging.rc == 0 else 0 }} {{ now().strftime('%s') }}
              esxi.patch.phase1.duration,host={{ inventory_hostname }} {{ duration }} {{ now().strftime('%s') }}
            status_code: [200, 201, 202, 204]
          delegate_to: localhost
          vars:
            ansible_connection: local
            ansible_python_interpreter: "{{ ansible_playbook_python }}"
          ignore_errors: yes
          when: staging is defined
          
        - name: Display results
          debug:
            msg:
              - "Staging: {{ 'SUCCESS' if staging.rc == 0 else 'FAILED' }}"
              - "Duration: {{ duration }} seconds"
              - "Patch Location: {{ patch_path }}"
          when: staging is defined
          
      rescue:
        - name: Send failure event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_ALERT"
              title: "ESXi Phase 1 Failed"
              properties:
                host: "{{ inventory_hostname }}"
                error: "{{ ansible_failed_result.msg|default('Unknown') }}"
            status_code: [200, 201, 202]
          delegate_to: localhost
          vars:
            ansible_connection: local
            ansible_python_interpreter: "{{ ansible_playbook_python }}"
          ignore_errors: yes
          
        - name: Cleanup temporary files
          raw: |
            find /vmfs/volumes -name "{{ patch_file }}.tmp" -delete 2>/dev/null || true
          ignore_errors: yes
          
        - name: Fail with instructions
          fail:
            msg: |
              Phase 1 failed. Manual steps:
              1. SSH to ESXi host
              2. Find patch: find /vmfs/volumes -name "{{ patch_file }}"
              3. Run: esxcli software profile update -d [patch_path] -p {{ patch_profile }} --no-live-install
              4. Reboot when ready
