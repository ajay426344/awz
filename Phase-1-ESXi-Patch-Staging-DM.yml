---
- name: Phase 1 - ESXi Patch Staging with Dynatrace Monitoring (HTTP Distribution)
  hosts: all
  gather_facts: no
  vars:
    ansible_user: root
    ansible_password: "Ajay@426344"
    ansible_connection: ssh
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
    patch_file: "VMware-ESXi-8.0U3g-24859861-depot.zip"
    patch_profile: "ESXi-8.0U3g-24859861-standard"
    # HTTP server configuration
    http_server_url: "http://192.168.1.100:8080"  # Replace with your HTTP server IP
    http_patch_path: "/patches"  # Path on HTTP server
    target_build: "24859861"
    dynatrace_url: "https://ofp39563.live.dynatrace.com"
    dynatrace_token: "dt0c01.MOQDVGYZV5NLQAAUFJMYVXM4.PNI42OD4D5V33H6IV4HQKJGB2VFDGJTPV3D6TKJBTMQ35JD62QIDNUM3OJKGQMVJ"
    
  tasks:
    - name: Set timestamps
      set_fact:
        current_epoch: "{{ now().strftime('%s') }}"
        current_iso: "{{ now().isoformat() }}"
      run_once: true
      
    - name: Record phase 1 start time
      set_fact:
        phase1_start_time: "{{ current_epoch }}"
        
    - name: Send Phase 1 start event to Dynatrace
      uri:
        url: "{{ dynatrace_url }}/api/v2/events/ingest"
        method: POST
        headers:
          Authorization: "Api-Token {{ dynatrace_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          eventType: "CUSTOM_INFO"
          title: "ESXi Phase 1 Staging Started"
          properties:
            host: "{{ inventory_hostname }}"
            phase: "phase1_staging"
            patch_file: "{{ patch_file }}"
            target_build: "{{ target_build }}"
            distribution_method: "http"
            severity: "INFO"
        status_code: [200, 201, 202]
      delegate_to: localhost
      vars:
        ansible_connection: local
      
    - name: Check if patch needed
      set_fact:
        needs_patching: "{{ hostvars[inventory_hostname]['host_current_build']|default('0')|int < target_build|int }}"
        
    - name: Send eligibility metric to Dynatrace
      uri:
        url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
        method: POST
        headers:
          Authorization: "Api-Token {{ dynatrace_token }}"
          Content-Type: "text/plain; charset=utf-8"
        body: |
          esxi.patch.phase1.eligibility,host={{ inventory_hostname }} {{ 1 if needs_patching else 0 }} {{ phase1_start_time }}
        status_code: [200, 201, 202, 204]
      delegate_to: localhost
      vars:
        ansible_connection: local
          
    - name: Execute staging process
      when: needs_patching
      block:
        - name: Create patches directory
          raw: mkdir -p {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches
          
        - name: Check if patch file already exists locally
          raw: ls -lh {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }} 2>/dev/null || echo "NOT_FOUND"
          register: patch_exists
          
        - name: Download patch from HTTP server
          when: "'NOT_FOUND' in patch_exists.stdout"
          block:
            - name: Record download start time
              set_fact:
                download_start: "{{ now().strftime('%s') }}"
                
            - name: Test HTTP server connectivity
              raw: |
                wget --spider --timeout=10 {{ http_server_url }}{{ http_patch_path }}/{{ patch_file }} 2>&1 | grep -q "200 OK" && echo "OK" || echo "FAILED"
              register: http_test
              failed_when: "'FAILED' in http_test.stdout"
              
            - name: Download patch file from HTTP server
              raw: |
                cd {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches && \
                wget -c --progress=dot:giga --timeout=600 \
                  {{ http_server_url }}{{ http_patch_path }}/{{ patch_file }} \
                  -O {{ patch_file }}.tmp && \
                mv {{ patch_file }}.tmp {{ patch_file }}
              register: download_result
              retries: 3
              delay: 10
              until: download_result.rc == 0
              
            - name: Verify downloaded file integrity
              raw: |
                ls -lh {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }} && \
                unzip -t {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }} > /dev/null 2>&1 && \
                echo "VALID" || echo "CORRUPT"
              register: file_check
              failed_when: "'CORRUPT' in file_check.stdout"
              
            - name: Calculate download duration and send to Dynatrace
              block:
                - set_fact:
                    download_duration: "{{ (now().strftime('%s') | int) - (download_start | int) }}"
                - uri:
                    url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
                    method: POST
                    headers:
                      Authorization: "Api-Token {{ dynatrace_token }}"
                      Content-Type: "text/plain; charset=utf-8"
                    body: |
                      esxi.patch.phase1.download_duration_seconds,host={{ inventory_hostname }} {{ download_duration }} {{ now().strftime('%s') }}
                      esxi.patch.phase1.download_method,host={{ inventory_hostname }},method=http 1 {{ now().strftime('%s') }}
                    status_code: [200, 201, 202, 204]
                  delegate_to: localhost
                  vars:
                    ansible_connection: local
                    
        - name: Send download status event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_INFO"
              title: "ESXi Patch Download {{ 'Cached' if 'NOT_FOUND' not in patch_exists.stdout else 'Completed' }}"
              properties:
                host: "{{ inventory_hostname }}"
                phase: "phase1_download"
                status: "{{ 'cached' if 'NOT_FOUND' not in patch_exists.stdout else 'downloaded' }}"
                download_duration: "{{ download_duration|default('0') }}"
                http_server: "{{ http_server_url }}"
                severity: "INFO"
            status_code: [200, 201, 202]
          delegate_to: localhost
          vars:
            ansible_connection: local
            
        - name: Perform dry-run
          raw: |
            esxcli software profile update \
              -d {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }} \
              -p {{ patch_profile }} \
              --dry-run
          register: dry_run_result
          
        - name: Send dry-run status to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "text/plain; charset=utf-8"
            body: |
              esxi.patch.phase1.dryrun_status,host={{ inventory_hostname }} {{ 1 if dry_run_result.rc == 0 else 0 }} {{ now().strftime('%s') }}
            status_code: [200, 201, 202, 204]
          delegate_to: localhost
          vars:
            ansible_connection: local
            
        - name: Stage patch with no-live-install
          raw: |
            esxcli software profile update \
              -d {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }} \
              -p {{ patch_profile }} \
              --no-live-install
          register: staging_result
          
        - name: Validate staging success
          set_fact:
            staging_success: "{{ 'The update completed successfully' in staging_result.stdout }}"
            reboot_required: "{{ 'Reboot Required: true' in staging_result.stdout }}"
            phase1_duration: "{{ (now().strftime('%s') | int) - (phase1_start_time | int) }}"
            
        - name: Send Phase 1 completion metrics to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "text/plain; charset=utf-8"
            body: |
              esxi.patch.phase1.staging_status,host={{ inventory_hostname }} {{ 1 if staging_success else 0 }} {{ now().strftime('%s') }}
              esxi.patch.phase1.reboot_required,host={{ inventory_hostname }} {{ 1 if reboot_required else 0 }} {{ now().strftime('%s') }}
              esxi.patch.phase1.duration_seconds,host={{ inventory_hostname }} {{ phase1_duration }} {{ now().strftime('%s') }}
            status_code: [200, 201, 202, 204]
          delegate_to: localhost
          vars:
            ansible_connection: local
          
        - name: Send Phase 1 completion event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_INFO"
              title: "ESXi Phase 1 {{ 'Completed' if staging_success else 'Failed' }}"
              properties:
                host: "{{ inventory_hostname }}"
                phase: "phase1_staging"
                status: "{{ 'success' if staging_success else 'failed' }}"
                duration_seconds: "{{ phase1_duration }}"
                reboot_required: "{{ reboot_required }}"
                distribution_method: "http"
                severity: "{{ 'INFO' if staging_success else 'ERROR' }}"
            status_code: [200, 201, 202]
          delegate_to: localhost
          vars:
            ansible_connection: local
            
      rescue:
        - name: Send failure event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_ERROR"
              title: "ESXi Phase 1 Failed"
              properties:
                host: "{{ inventory_hostname }}"
                phase: "phase1_staging"
                status: "failed"
                error: "{{ ansible_failed_result.msg|default('Unknown error') }}"
                severity: "ERROR"
            status_code: [200, 201, 202]
          delegate_to: localhost
          vars:
            ansible_connection: local
            
        - name: Cleanup partial download on failure
          raw: |
            rm -f {{ hostvars[inventory_hostname]['host_selected_datastore']|default('/vmfs/volumes/datastore1') }}/patches/{{ patch_file }}.tmp 2>/dev/null || true
          ignore_errors: yes
          
    - name: Send skip notification if patch not needed
      uri:
        url: "{{ dynatrace_url }}/api/v2/events/ingest"
        method: POST
        headers:
          Authorization: "Api-Token {{ dynatrace_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          eventType: "CUSTOM_INFO"
          title: "ESXi Phase 1 Skipped - Already Updated"
          properties:
            host: "{{ inventory_hostname }}"
            phase: "phase1_staging"
            status: "skipped"
            current_build: "{{ hostvars[inventory_hostname]['host_current_build']|default('unknown') }}"
            target_build: "{{ target_build }}"
            severity: "INFO"
        status_code: [200, 201, 202]
      delegate_to: localhost
      vars:
        ansible_connection: local
      when: not needs_patching
