---
- name: Phase 1 - ESXi Patch Staging with HTTP Port 80
  hosts: all
  gather_facts: no
  vars:
    ansible_user: root
    ansible_password: "Ajay@426344"
    ansible_connection: ssh
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
    
    # Patch configuration
    patch_file: "VMware-ESXi-8.0U3g-24859861-depot.zip"
    patch_profile: "ESXi-8.0U3g-24859861-standard"
    target_build: "24859861"
    
    # HTTP server configuration - Using Port 80
    http_server_url: "http://192.168.0.110"  # No port needed for 80
    
    # Dynatrace configuration
    dynatrace_url: "https://ofp39563.live.dynatrace.com"
    dynatrace_token: "dt0c01.MOQDVGYZV5NLQAAUFJMYVXM4.PNI42OD4D5V33H6IV4HQKJGB2VFDGJTPV3D6TKJBTMQ35JD62QIDNUM3OJKGQMVJ"
    enable_dynatrace: true  # Set to false to disable Dynatrace
    
    # ESXi datastore configuration
    default_datastore: "/vmfs/volumes/datastore1"
    
  tasks:
    - name: Phase 1 Start
      block:
        - name: Set start timestamp
          set_fact:
            phase1_start_time: "{{ now().strftime('%s') }}"
            phase1_start_iso: "{{ now().isoformat() }}"
            
        - name: Display phase information
          debug:
            msg:
              - "========================================"
              - "ESXi PATCH PHASE 1 - STAGING"
              - "========================================"
              - "Host: {{ inventory_hostname }}"
              - "HTTP Server: {{ http_server_url }}"
              - "Patch File: {{ patch_file }}"
              - "Target Build: {{ target_build }}"
              - "Started: {{ phase1_start_iso }}"
              
        - name: Send start event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_INFO"
              title: "ESXi Phase 1 Staging Started"
              properties:
                host: "{{ inventory_hostname }}"
                phase: "phase1_staging"
                patch_file: "{{ patch_file }}"
                target_build: "{{ target_build }}"
                http_server: "{{ http_server_url }}"
                severity: "INFO"
            status_code: [200, 201, 202]
          delegate_to: localhost
          become: no
          vars:
            ansible_connection: local
            ansible_python_interpreter: "{{ ansible_playbook_python }}"
          when: enable_dynatrace
          ignore_errors: yes
          
    - name: Pre-flight checks
      block:
        - name: Get ESXi version info
          raw: |
            vmware -vl
          register: esxi_version
          
        - name: Display ESXi version
          debug:
            msg: "Current ESXi: {{ esxi_version.stdout_lines[0] if esxi_version.stdout_lines else 'Unknown' }}"
            
        - name: Check current build number
          set_fact:
            current_build: "{{ hostvars[inventory_hostname]['host_current_build']|default('0') }}"
            needs_patching: "{{ hostvars[inventory_hostname]['host_current_build']|default('0')|int < target_build|int }}"
            
        - name: Display patching decision
          debug:
            msg:
              - "Current Build: {{ current_build }}"
              - "Target Build: {{ target_build }}"
              - "Needs Patching: {{ 'YES' if needs_patching else 'NO - Already up to date' }}"
              
    - name: Main patching process
      when: needs_patching
      block:
        - name: Determine datastore path
          set_fact:
            datastore_path: "{{ hostvars[inventory_hostname]['host_selected_datastore']|default(default_datastore) }}"
            
        - name: Ensure patches directory exists
          raw: |
            mkdir -p "{{ datastore_path }}/patches"
            echo "Patches directory: {{ datastore_path }}/patches"
            df -h "{{ datastore_path }}" | tail -1
          register: dir_created
          
        - name: Check available space
          debug:
            msg: "{{ dir_created.stdout_lines }}"
            
        - name: Check if patch already exists
          raw: |
            FILE="{{ datastore_path }}/patches/{{ patch_file }}"
            if [ -f "$FILE" ]; then
              SIZE=$(ls -l "$FILE" | awk '{print $5}')
              echo "STATUS: EXISTS"
              echo "SIZE: $SIZE"
              if [ $SIZE -gt 900000000 ]; then
                echo "VALID: YES"
              else
                echo "VALID: NO - Too small, will re-download"
                rm -f "$FILE"
              fi
            else
              echo "STATUS: NOT_FOUND"
            fi
          register: patch_check
          
        - name: Display patch status
          debug:
            msg: "{{ patch_check.stdout_lines }}"
            
        - name: Download patch if needed
          when: "'NOT_FOUND' in patch_check.stdout"
          block:
            - name: Record download start
              set_fact:
                download_start: "{{ now().strftime('%s') }}"
                
            - name: Enable HTTP client firewall rule
              raw: |
                esxcli network firewall ruleset set -e true -r httpClient
                esxcli network firewall ruleset list | grep httpClient
              register: firewall_enabled
              
            - name: Download patch from HTTP server (Port 80)
              raw: |
                cd "{{ datastore_path }}/patches"
                echo "Downloading from: {{ http_server_url }}/{{ patch_file }}"
                
                # ESXi wget (BusyBox) - simple syntax, no timeout option
                wget -O "{{ patch_file }}.downloading" "{{ http_server_url }}/{{ patch_file }}"
                RESULT=$?
                
                if [ $RESULT -eq 0 ]; then
                  mv "{{ patch_file }}.downloading" "{{ patch_file }}"
                  echo "DOWNLOAD: SUCCESS"
                  ls -lh "{{ patch_file }}"
                else
                  rm -f "{{ patch_file }}.downloading"
                  echo "DOWNLOAD: FAILED with code $RESULT"
                  exit 1
                fi
              register: download_result
              retries: 3
              delay: 30
              until: download_result.rc == 0
              
            - name: Show download result
              debug:
                msg: "{{ download_result.stdout_lines }}"
                
            - name: Calculate download time
              set_fact:
                download_duration: "{{ (now().strftime('%s')|int) - (download_start|int) }}"
              when: download_result.rc == 0
              
            - name: Report download metrics to Dynatrace
              uri:
                url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
                method: POST
                headers:
                  Authorization: "Api-Token {{ dynatrace_token }}"
                  Content-Type: "text/plain; charset=utf-8"
                body: |
                  esxi.patch.phase1.download_duration_seconds,host={{ inventory_hostname }} {{ download_duration }} {{ now().strftime('%s') }}
                  esxi.patch.phase1.download_size_bytes,host={{ inventory_hostname }} 1020256846 {{ now().strftime('%s') }}
                status_code: [200, 201, 202, 204]
              delegate_to: localhost
              become: no
              vars:
                ansible_connection: local
                ansible_python_interpreter: "{{ ansible_playbook_python }}"
              when: enable_dynatrace and download_duration is defined
              ignore_errors: yes
              
        - name: Verify patch integrity
          raw: |
            FILE="{{ datastore_path }}/patches/{{ patch_file }}"
            if [ -f "$FILE" ]; then
              SIZE=$(ls -l "$FILE" | awk '{print $5}')
              echo "File: $FILE"
              echo "Size: $SIZE bytes ($(( SIZE / 1024 / 1024 )) MB)"
              if [ $SIZE -gt 900000000 ]; then
                echo "VALIDATION: PASSED"
              else
                echo "VALIDATION: FAILED - File too small"
                exit 1
              fi
            else
              echo "VALIDATION: FAILED - File not found"
              exit 1
            fi
          register: validation
          
        - name: Display validation result
          debug:
            msg: "{{ validation.stdout_lines }}"
            
        - name: Perform dry-run test
          raw: |
            echo "Starting dry-run validation..."
            esxcli software profile update \
              -d "{{ datastore_path }}/patches/{{ patch_file }}" \
              -p "{{ patch_profile }}" \
              --dry-run 2>&1
          register: dry_run
          ignore_errors: yes
          
        - name: Display dry-run results
          debug:
            msg: 
              - "Dry-run completed with RC: {{ dry_run.rc }}"
              - "{{ dry_run.stdout_lines[:15] if dry_run.stdout_lines else dry_run.stdout }}"
              
        - name: Stage patch (no-live-install)
          raw: |
            echo "Staging patch with no-live-install..."
            esxcli software profile update \
              -d "{{ datastore_path }}/patches/{{ patch_file }}" \
              -p "{{ patch_profile }}" \
              --no-live-install 2>&1
          register: staging_result
          
        - name: Parse staging results
          set_fact:
            staging_success: "{{ staging_result.rc == 0 and ('successfully' in staging_result.stdout|lower or 'complete' in staging_result.stdout|lower) }}"
            reboot_required: "{{ 'Reboot Required: true' in staging_result.stdout }}"
            phase1_duration: "{{ (now().strftime('%s')|int) - (phase1_start_time|int) }}"
            
        - name: Display staging summary
          debug:
            msg:
              - "========================================"
              - "PHASE 1 STAGING RESULTS"
              - "========================================"
              - "Status: {{ 'SUCCESS ✓' if staging_success else 'FAILED ✗' }}"
              - "Reboot Required: {{ 'Yes' if reboot_required else 'No' }}"
              - "Duration: {{ phase1_duration }} seconds"
              - "{{ staging_result.stdout_lines[:20] if staging_result.stdout_lines else staging_result.stdout }}"
              
        - name: Send completion metrics to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "text/plain; charset=utf-8"
            body: |
              esxi.patch.phase1.staging_status,host={{ inventory_hostname }} {{ 1 if staging_success else 0 }} {{ now().strftime('%s') }}
              esxi.patch.phase1.reboot_required,host={{ inventory_hostname }} {{ 1 if reboot_required else 0 }} {{ now().strftime('%s') }}
              esxi.patch.phase1.duration_seconds,host={{ inventory_hostname }} {{ phase1_duration }} {{ now().strftime('%s') }}
            status_code: [200, 201, 202, 204]
          delegate_to: localhost
          become: no
          vars:
            ansible_connection: local
            ansible_python_interpreter: "{{ ansible_playbook_python }}"
          when: enable_dynatrace
          ignore_errors: yes
          
        - name: Send completion event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_INFO"
              title: "ESXi Phase 1 {{ 'Completed Successfully' if staging_success else 'Failed' }}"
              properties:
                host: "{{ inventory_hostname }}"
                phase: "phase1_staging"
                status: "{{ 'success' if staging_success else 'failed' }}"
                reboot_required: "{{ reboot_required }}"
                duration_seconds: "{{ phase1_duration }}"
                http_server: "{{ http_server_url }}"
                severity: "{{ 'INFO' if staging_success else 'ERROR' }}"
            status_code: [200, 201, 202]
          delegate_to: localhost
          become: no
          vars:
            ansible_connection: local
            ansible_python_interpreter: "{{ ansible_playbook_python }}"
          when: enable_dynatrace
          ignore_errors: yes
          
      rescue:
        - name: Handle staging failure
          debug:
            msg:
              - "========================================"
              - "PHASE 1 FAILED"
              - "========================================"
              - "Task: {{ ansible_failed_task.name|default('Unknown') }}"
              - "Error: {{ ansible_failed_result.msg|default('Check output above') }}"
              
        - name: Cleanup on failure
          raw: |
            rm -f "{{ datastore_path|default(default_datastore) }}/patches/{{ patch_file }}.downloading" 2>/dev/null
            rm -f "{{ datastore_path|default(default_datastore) }}/patches/{{ patch_file }}.tmp" 2>/dev/null
          ignore_errors: yes
          
        - name: Send failure event to Dynatrace
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_ALERT"
              title: "ESXi Phase 1 Failed"
              properties:
                host: "{{ inventory_hostname }}"
                phase: "phase1_staging"
                status: "failed"
                failed_task: "{{ ansible_failed_task.name|default('Unknown') }}"
                error: "{{ ansible_failed_result.msg|default('Unknown error') }}"
                severity: "ERROR"
            status_code: [200, 201, 202]
          delegate_to: localhost
          become: no
          vars:
            ansible_connection: local
            ansible_python_interpreter: "{{ ansible_playbook_python }}"
          when: enable_dynatrace
          ignore_errors: yes
          
    - name: Skip notification when already patched
      when: not needs_patching
      debug:
        msg:
          - "========================================"
          - "PATCHING SKIPPED"
          - "========================================"
          - "Host is already at or above target build {{ target_build }}"
          - "Current build: {{ current_build }}"
