---
# esxi_precheck.yml
# ESXi Pre-check Stage with Automated SSH Management for AWX
# This playbook performs pre-checks only and reports readiness for patching

- name: ESXi Pre-check with Automated SSH Management
  hosts: all
  gather_facts: no
  serial: 1  # Process one host at a time
  
  vars:
    # Host Configuration
    target_host: "{{ ansible_host | default(inventory_hostname) }}"
    ansible_user: "root"
    ansible_password: "{{ esxi_password | default('Ajay@426344') }}"
    ansible_connection: ssh
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
    
    # SSH Management
    manage_ssh_automatically: "{{ enable_auto_ssh | default(true) }}"
    disable_ssh_after_check: "{{ disable_ssh_post_check | default(true) }}"
    
    # Patch Configuration for Validation
    target_build: "{{ esxi_target_build | default('24859861') }}"
    minimum_space_gb: "{{ min_space_gb | default(3) }}"
    
    # Dynatrace Configuration
    dynatrace_url: "{{ dt_url | default('https://ofp39563.live.dynatrace.com') }}"
    dynatrace_token: "{{ dt_api_token | default('') }}"
    enable_dynatrace: "{{ use_dynatrace | default(true) }}"
    
  tasks:
    # =========================================================================
    # STAGE 1: SSH ENABLEMENT VIA API
    # =========================================================================
    - name: "STAGE 1: Enable SSH via API"
      when: manage_ssh_automatically | bool
      block:
        - name: Display target information
          debug:
            msg:
              - "Target Host: {{ inventory_hostname }}"
              - "IP Address: {{ target_host }}"
              - "SSH Auto-Management: {{ 'Enabled' if manage_ssh_automatically else 'Disabled' }}"
              
        - name: Check HTTPS connectivity to ESXi host
          wait_for:
            host: "{{ target_host }}"
            port: 443
            state: started
            timeout: 10
          delegate_to: localhost
          register: https_check
          
        - name: Login to ESXi SOAP API
          uri:
            url: "https://{{ target_host }}/sdk"
            method: POST
            validate_certs: no
            force_basic_auth: yes
            user: "{{ ansible_user }}"
            password: "{{ ansible_password }}"
            headers:
              Content-Type: "text/xml; charset=utf-8"
              SOAPAction: "urn:vim25/8.0"
            body: |
              <?xml version="1.0" encoding="UTF-8"?>
              <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                xmlns:vim="urn:vim25">
                <soapenv:Body>
                  <vim:Login>
                    <vim:_this type="SessionManager">ha-sessionmgr</vim:_this>
                    <vim:userName>{{ ansible_user }}</vim:userName>
                    <vim:password>{{ ansible_password }}</vim:password>
                  </vim:Login>
                </soapenv:Body>
              </soapenv:Envelope>
            timeout: 30
          delegate_to: localhost
          register: soap_login
          
        - name: Extract session cookie
          set_fact:
            vmware_session: "{{ soap_login.cookies['vmware_soap_session'] | default('') }}"
          when: soap_login is success
          
        - name: Start SSH service (TSM-SSH)
          uri:
            url: "https://{{ target_host }}/sdk"
            method: POST
            validate_certs: no
            headers:
              Content-Type: "text/xml; charset=utf-8"
              SOAPAction: "urn:vim25/8.0"
              Cookie: "vmware_soap_session={{ vmware_session }}"
            body: |
              <?xml version="1.0" encoding="UTF-8"?>
              <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                xmlns:vim="urn:vim25">
                <soapenv:Body>
                  <vim:StartService>
                    <vim:_this type="HostServiceSystem">ha-host-service-system</vim:_this>
                    <vim:id>TSM-SSH</vim:id>
                  </vim:StartService>
                </soapenv:Body>
              </soapenv:Envelope>
            timeout: 30
          delegate_to: localhost
          when: vmware_session is defined
          register: ssh_start
          
        - name: Set SSH service policy to 'on'
          uri:
            url: "https://{{ target_host }}/sdk"
            method: POST
            validate_certs: no
            headers:
              Content-Type: "text/xml; charset=utf-8"
              SOAPAction: "urn:vim25/8.0"
              Cookie: "vmware_soap_session={{ vmware_session }}"
            body: |
              <?xml version="1.0" encoding="UTF-8"?>
              <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                xmlns:vim="urn:vim25">
                <soapenv:Body>
                  <vim:UpdateServicePolicy>
                    <vim:_this type="HostServiceSystem">ha-host-service-system</vim:_this>
                    <vim:id>TSM-SSH</vim:id>
                    <vim:policy>on</vim:policy>
                  </vim:UpdateServicePolicy>
                </soapenv:Body>
              </soapenv:Envelope>
            timeout: 30
          delegate_to: localhost
          when: vmware_session is defined
          
        - name: Wait for SSH port to become available
          wait_for:
            host: "{{ target_host }}"
            port: 22
            state: started
            delay: 5
            timeout: 60
          delegate_to: localhost
          register: ssh_wait
          
        - name: Mark SSH as enabled by automation
          set_fact:
            ssh_enabled_by_automation: true
            ssh_enable_timestamp: "{{ ansible_date_time.epoch | default(now().strftime('%s')) }}"
          when: ssh_wait is success
          
      rescue:
        - name: SSH enablement failed - continuing with assumption SSH is already enabled
          debug:
            msg: "Failed to enable SSH via API. Assuming SSH is already enabled and continuing..."
          
        - name: Set SSH pre-existing flag
          set_fact:
            ssh_enabled_by_automation: false
            ssh_was_preexisting: true
            
    # =========================================================================
    # STAGE 2: PRE-CHECK VALIDATION
    # =========================================================================
    - name: "STAGE 2: Pre-check Validation"
      block:
        - name: Set pre-check timestamps
          set_fact:
            precheck_start_epoch: "{{ now().strftime('%s') }}"
            precheck_start_iso: "{{ now().isoformat() }}"
            
        - name: Send pre-check start event to Dynatrace
          when: 
            - enable_dynatrace | bool
            - dynatrace_token != ''
          uri:
            url: "{{ dynatrace_url }}/api/v2/events/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              eventType: "CUSTOM_INFO"
              title: "ESXi Pre-check Started"
              properties:
                host: "{{ inventory_hostname }}"
                target_ip: "{{ target_host }}"
                phase: "precheck"
                timestamp: "{{ precheck_start_iso }}"
            status_code: [200, 201, 202]
          delegate_to: localhost
          ignore_errors: yes
          
        - name: Test SSH connectivity
          wait_for_connection:
            timeout: 30
          register: ssh_check
          
        - name: Get ESXi version information
          raw: vmware -v
          register: version_output
          
        - name: Get ESXi detailed version
          raw: vmware -vl
          register: version_detailed
          ignore_errors: yes
          
        - name: Extract current build number
          raw: vmware -v | grep -o 'build-[0-9]*' | cut -d'-' -f2
          register: current_build_raw
          
        - name: Check all datastores for available space
          raw: |
            echo "=== Datastore Space Check ==="
            # Method 1: Using df
            for DS in /vmfs/volumes/datastore*; do
              if [ -d "$DS" ]; then
                DS_NAME=$(basename "$DS")
                FREE_RAW=$(df -h "$DS" 2>/dev/null | tail -1 | awk '{print $4}')
                TOTAL_RAW=$(df -h "$DS" 2>/dev/null | tail -1 | awk '{print $2}')
                
                # Convert to GB
                FREE_GB=0
                if echo "$FREE_RAW" | grep -q "G"; then
                  FREE_GB=$(echo "$FREE_RAW" | sed 's/G//')
                elif echo "$FREE_RAW" | grep -q "T"; then
                  FREE_GB=$(echo "$FREE_RAW" | sed 's/T//' | awk '{print $1 * 1024}')
                elif echo "$FREE_RAW" | grep -q "M"; then
                  FREE_GB=$(echo "$FREE_RAW" | sed 's/M//' | awk '{print $1 / 1024}')
                fi
                
                echo "Datastore: $DS_NAME"
                echo "  Path: $DS"
                echo "  Total: $TOTAL_RAW"
                echo "  Free: $FREE_RAW (${FREE_GB}GB)"
                echo "RESULT:$DS:$FREE_GB"
              fi
            done | grep "RESULT:" | sort -t: -k3 -rn | head -1
          register: datastore_check
          
        - name: Alternative datastore check using esxcli
          when: datastore_check.stdout == ""
          raw: |
            esxcli storage filesystem list | grep -E "VMFS|NFS" | while read line; do
              VOL=$(echo "$line" | awk '{print $2}')
              SIZE=$(echo "$line" | awk '{print $3}')
              FREE=$(echo "$line" | awk '{print $5}')
              if [ "$FREE" -gt 0 ] 2>/dev/null; then
                FREE_GB=$((FREE / 1073741824))
                echo "${VOL}:${FREE_GB}"
              fi
            done | sort -t: -k2 -rn | head -1
          register: datastore_esxcli
          
        - name: Check system health status
          raw: |
            echo "=== System Health Check ==="
            # Check CPU and Memory
            esxcli hardware cpu global get | grep -E "CPU Packages|CPU Cores"
            esxcli hardware memory get | grep "Physical Memory"
            
            # Check for any hardware alerts
            esxcli hardware ipmi sdr list 2>/dev/null | grep -i "error\|critical\|warning" | head -5 || echo "No critical hardware alerts"
          register: health_check
          ignore_errors: yes
          
        - name: Check running VMs count
          raw: |
            TOTAL_VMS=$(vim-cmd vmsvc/getallvms 2>/dev/null | tail -n +2 | wc -l)
            POWERED_ON=0
            for VMID in $(vim-cmd vmsvc/getallvms 2>/dev/null | tail -n +2 | awk '{print $1}'); do
              STATE=$(vim-cmd vmsvc/power.getstate $VMID 2>/dev/null | tail -1)
              if echo "$STATE" | grep -q "Powered on"; then
                POWERED_ON=$((POWERED_ON + 1))
              fi
            done
            echo "Total VMs: $TOTAL_VMS"
            echo "Powered On: $POWERED_ON"
            echo "VM_COUNT:$TOTAL_VMS:$POWERED_ON"
          register: vm_count
          
        - name: Check maintenance mode status
          raw: esxcli system maintenanceMode get
          register: maintenance_mode
          
        - name: Parse collected information
          set_fact:
            # Basic info
            host_ssh_status: "{{ 'PASS' if ssh_check.elapsed < 30 else 'FAIL' }}"
            host_current_build: "{{ current_build_raw.stdout | trim }}"
            host_version: "{{ version_output.stdout | trim }}"
            host_version_detailed: "{{ version_detailed.stdout | default('N/A') | trim }}"
            
            # Datastore info
            datastore_result: >-
              {%- if datastore_check.stdout and 'RESULT:' in datastore_check.stdout -%}
                {{ datastore_check.stdout | regex_search('RESULT:(.*)$', '\\1') | first }}
              {%- elif datastore_esxcli.stdout | default('') -%}
                {{ datastore_esxcli.stdout | trim }}
              {%- else -%}
                none:0
              {%- endif -%}
            
            # VM info
            vm_info: >-
              {%- if vm_count.stdout and 'VM_COUNT:' in vm_count.stdout -%}
                {{ vm_count.stdout | regex_search('VM_COUNT:(.*)$', '\\1') | first }}
              {%- else -%}
                0:0
              {%- endif -%}
            
            # Maintenance mode
            is_in_maintenance: "{{ 'Enabled' in maintenance_mode.stdout }}"
            
        - name: Set derived facts
          set_fact:
            host_selected_datastore: "{{ datastore_result.split(':')[0] if ':' in datastore_result else 'none' }}"
            host_available_space: "{{ datastore_result.split(':')[1] | float if ':' in datastore_result else 0 }}"
            total_vms: "{{ vm_info.split(':')[0] | int if ':' in vm_info else 0 }}"
            powered_on_vms: "{{ vm_info.split(':')[1] | int if ':' in vm_info else 0 }}"
            needs_patching: "{{ host_current_build | int < target_build | int }}"
            
        - name: Determine pre-check status
          set_fact:
            precheck_passed: "{{ host_ssh_status == 'PASS' and host_available_space | float >= minimum_space_gb | float }}"
            precheck_warnings: >-
              {%- set warnings = [] -%}
              {%- if host_ssh_status != 'PASS' -%}
                {%- set _ = warnings.append('SSH connectivity issue') -%}
              {%- endif -%}
              {%- if host_available_space | float < minimum_space_gb | float -%}
                {%- set _ = warnings.append('Insufficient space: ' + host_available_space | string + 'GB available, ' + minimum_space_gb | string + 'GB required') -%}
              {%- endif -%}
              {%- if powered_on_vms | int > 0 -%}
                {%- set _ = warnings.append(powered_on_vms | string + ' VMs are powered on') -%}
              {%- endif -%}
              {%- if is_in_maintenance -%}
                {%- set _ = warnings.append('Host is in maintenance mode') -%}
              {%- endif -%}
              {{ warnings | join(', ') if warnings else 'None' }}
              
        - name: Send pre-check metrics to Dynatrace
          when: 
            - enable_dynatrace | bool
            - dynatrace_token != ''
          uri:
            url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
            method: POST
            headers:
              Authorization: "Api-Token {{ dynatrace_token }}"
              Content-Type: "text/plain; charset=utf-8"
            body: |
              esxi.precheck.ssh_status,host={{ inventory_hostname }} {{ 1 if host_ssh_status == 'PASS' else 0 }} {{ precheck_start_epoch }}
              esxi.precheck.build_number,host={{ inventory_hostname }} {{ host_current_build }} {{ precheck_start_epoch }}
              esxi.precheck.datastore_space_gb,host={{ inventory_hostname }} {{ host_available_space }} {{ precheck_start_epoch }}
              esxi.precheck.vm_count_total,host={{ inventory_hostname }} {{ total_vms }} {{ precheck_start_epoch }}
              esxi.precheck.vm_count_powered,host={{ inventory_hostname }} {{ powered_on_vms }} {{ precheck_start_epoch }}
              esxi.precheck.status,host={{ inventory_hostname }} {{ 1 if precheck_passed else 0 }} {{ precheck_start_epoch }}
              esxi.precheck.needs_patching,host={{ inventory_hostname }} {{ 1 if needs_patching else 0 }} {{ precheck_start_epoch }}
            status_code: [200, 201, 202, 204]
          delegate_to: localhost
          ignore_errors: yes
          
    # =========================================================================
    # STAGE 3: DISABLE SSH IF ENABLED BY AUTOMATION
    # =========================================================================
    - name: "STAGE 3: Disable SSH (if enabled by automation)"
      when: 
        - manage_ssh_automatically | bool
        - disable_ssh_after_check | bool
        - ssh_enabled_by_automation | default(false)
      block:
        - name: Re-authenticate for SSH disable
          uri:
            url: "https://{{ target_host }}/sdk"
            method: POST
            validate_certs: no
            force_basic_auth: yes
            user: "{{ ansible_user }}"
            password: "{{ ansible_password }}"
            headers:
              Content-Type: "text/xml; charset=utf-8"
              SOAPAction: "urn:vim25/8.0"
            body: |
              <?xml version="1.0" encoding="UTF-8"?>
              <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                xmlns:vim="urn:vim25">
                <soapenv:Body>
                  <vim:Login>
                    <vim:_this type="SessionManager">ha-sessionmgr</vim:_this>
                    <vim:userName>{{ ansible_user }}</vim:userName>
                    <vim:password>{{ ansible_password }}</vim:password>
                  </vim:Login>
                </soapenv:Body>
              </soapenv:Envelope>
            timeout: 30
          delegate_to: localhost
          register: soap_reauth
          
        - name: Stop SSH service
          uri:
            url: "https://{{ target_host }}/sdk"
            method: POST
            validate_certs: no
            headers:
              Content-Type: "text/xml; charset=utf-8"
              SOAPAction: "urn:vim25/8.0"
              Cookie: "vmware_soap_session={{ soap_reauth.cookies['vmware_soap_session'] }}"
            body: |
              <?xml version="1.0" encoding="UTF-8"?>
              <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                xmlns:vim="urn:vim25">
                <soapenv:Body>
                  <vim:StopService>
                    <vim:_this type="HostServiceSystem">ha-host-service-system</vim:_this>
                    <vim:id>TSM-SSH</vim:id>
                  </vim:StopService>
                </soapenv:Body>
              </soapenv:Envelope>
            timeout: 30
          delegate_to: localhost
          when: soap_reauth is success
          
        - name: Set SSH service policy to 'off'
          uri:
            url: "https://{{ target_host }}/sdk"
            method: POST
            validate_certs: no
            headers:
              Content-Type: "text/xml; charset=utf-8"
              SOAPAction: "urn:vim25/8.0"
              Cookie: "vmware_soap_session={{ soap_reauth.cookies['vmware_soap_session'] }}"
            body: |
              <?xml version="1.0" encoding="UTF-8"?>
              <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                xmlns:vim="urn:vim25">
                <soapenv:Body>
                  <vim:UpdateServicePolicy>
                    <vim:_this type="HostServiceSystem">ha-host-service-system</vim:_this>
                    <vim:id>TSM-SSH</vim:id>
                    <vim:policy>off</vim:policy>
                  </vim:UpdateServicePolicy>
                </soapenv:Body>
              </soapenv:Envelope>
            timeout: 30
          delegate_to: localhost
          when: soap_reauth is success
          
        - name: Verify SSH is disabled
          wait_for:
            host: "{{ target_host }}"
            port: 22
            state: stopped
            timeout: 30
          delegate_to: localhost
          vars:
            ansible_connection: local
          ignore_errors: yes
          register: ssh_disabled_check
          
        - name: Set SSH disabled flag
          set_fact:
            ssh_was_disabled: "{{ ssh_disabled_check is success }}"
            
    # =========================================================================
    # FINAL: DISPLAY RESULTS
    # =========================================================================
    - name: Display pre-check results
      debug:
        msg:
          - "========================================="
          - "ESXi PRE-CHECK RESULTS"
          - "========================================="
          - "Host: {{ inventory_hostname }}"
          - "IP Address: {{ target_host }}"
          - "========================================="
          - "SYSTEM INFORMATION:"
          - "  Current Version: {{ host_version }}"
          - "  Current Build: {{ host_current_build }}"
          - "  Target Build: {{ target_build }}"
          - "  Needs Patching: {{ 'YES ⚠' if needs_patching else 'NO ✓' }}"
          - "========================================="
          - "RESOURCE STATUS:"
          - "  SSH Connectivity: {{ host_ssh_status }}"
          - "  Selected Datastore: {{ host_selected_datastore }}"
          - "  Available Space: {{ host_available_space }}GB"
          - "  Required Space: {{ minimum_space_gb }}GB"
          - "  Space Check: {{ 'PASS ✓' if host_available_space | float >= minimum_space_gb | float else 'FAIL ✗' }}"
          - "========================================="
          - "VM STATUS:"
          - "  Total VMs: {{ total_vms }}"
          - "  Powered On: {{ powered_on_vms }}"
          - "  Maintenance Mode: {{ 'YES' if is_in_maintenance else 'NO' }}"
          - "========================================="
          - "PRE-CHECK STATUS: {{ 'PASSED ✓' if precheck_passed else 'FAILED ✗' }}"
          - "WARNINGS: {{ precheck_warnings }}"
          - "========================================="
          - "SSH MANAGEMENT:"
          - "  SSH Auto-Enabled: {{ 'YES' if ssh_enabled_by_automation | default(false) else 'NO' }}"
          - "  SSH Auto-Disabled: {{ 'YES' if ssh_was_disabled | default(false) else 'N/A' }}"
          - "========================================="
          
    - name: Set statistics for AWX
      set_stats:
        data:
          precheck_status: "{{ 'passed' if precheck_passed else 'failed' }}"
          needs_patching: "{{ needs_patching }}"
          current_build: "{{ host_current_build }}"
          target_build: "{{ target_build }}"
          available_space_gb: "{{ host_available_space }}"
          required_space_gb: "{{ minimum_space_gb }}"
          total_vms: "{{ total_vms }}"
          powered_on_vms: "{{ powered_on_vms }}"
          ssh_auto_managed: "{{ ssh_enabled_by_automation | default(false) }}"
          warnings: "{{ precheck_warnings }}"
          
    - name: Fail if pre-check doesn't pass and enforcement is enabled
      fail:
        msg: "Pre-check FAILED! {{ precheck_warnings }}"
      when: 
        - not precheck_passed
        - enforce_precheck | default(false) | bool
