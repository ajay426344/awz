---
# stage1_precheck.yml
# Stage 1: ESXi Pre-check with Automated SSH Management via SOAP API
# Requires: ESXi with proper license (vSphere Essentials or higher)

- name: "Stage 1: ESXi Pre-check with SSH Automation"
  hosts: all
  gather_facts: no
  serial: 1
  connection: local  # Start local, switch to SSH after enabling
  
  vars:
    # Host Configuration
    target_host: "{{ ansible_host | default(inventory_hostname) }}"
    esxi_username: "root"
    esxi_password: "{{ vault_esxi_password | default('Ajay@426344') }}"
    
    # SSH Management
    enable_ssh_automatically: "{{ auto_ssh | default(true) }}"
    keep_ssh_enabled: "{{ persistent_ssh | default(false) }}"
    
    # Validation Parameters
    target_build: "{{ esxi_target_build | default('24859861') }}"
    minimum_space_gb: "{{ min_datastore_space | default(3) }}"
    patch_file: "{{ esxi_patch_file | default('VMware-ESXi-8.0U3g-24859861-depot.zip') }}"
    
    # Dynatrace Monitoring
    dynatrace_enabled: "{{ enable_dynatrace | default(true) }}"
    dynatrace_url: "{{ dt_url | default('https://ofp39563.live.dynatrace.com') }}"
    dynatrace_token: "{{ dt_api_token }}"
    
  tasks:
    # =========================================================================
    # SECTION 1: SSH ENABLEMENT
    # =========================================================================
    - name: "1.1: Initialize Pre-check"
      set_fact:
        precheck_timestamp: "{{ now().strftime('%s') }}"
        precheck_date: "{{ now().isoformat() }}"
        ssh_was_enabled_by_automation: false
        
    - name: "1.2: Enable SSH via SOAP API"
      when: enable_ssh_automatically | bool
      block:
        - name: Check HTTPS connectivity
          wait_for:
            host: "{{ target_host }}"
            port: 443
            state: started
            timeout: 10
          delegate_to: localhost
          vars:
            ansible_connection: local
            
        - name: Login to ESXi SOAP API
          uri:
            url: "https://{{ target_host }}/sdk"
            method: POST
            validate_certs: no
            force_basic_auth: yes
            user: "{{ esxi_username }}"
            password: "{{ esxi_password }}"
            headers:
              Content-Type: "text/xml; charset=utf-8"
              SOAPAction: "urn:vim25/8.0"
            body: |
              <?xml version="1.0" encoding="UTF-8"?>
              <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                xmlns:vim="urn:vim25">
                <soapenv:Body>
                  <vim:Login>
                    <vim:_this type="SessionManager">ha-sessionmgr</vim:_this>
                    <vim:userName>{{ esxi_username }}</vim:userName>
                    <vim:password>{{ esxi_password }}</vim:password>
                  </vim:Login>
                </soapenv:Body>
              </soapenv:Envelope>
            timeout: 30
          delegate_to: localhost
          vars:
            ansible_connection: local
          register: soap_login
          
        - name: Store session cookie
          set_fact:
            vmware_session: "{{ soap_login.cookies['vmware_soap_session'] }}"
          when: soap_login is success
          
        - name: Start SSH service (TSM-SSH)
          uri:
            url: "https://{{ target_host }}/sdk"
            method: POST
            validate_certs: no
            headers:
              Content-Type: "text/xml; charset=utf-8"
              SOAPAction: "urn:vim25/8.0"
              Cookie: "vmware_soap_session={{ vmware_session }}"
            body: |
              <?xml version="1.0" encoding="UTF-8"?>
              <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                xmlns:vim="urn:vim25">
                <soapenv:Body>
                  <vim:StartService>
                    <vim:_this type="HostServiceSystem">hostServiceSystem</vim:_this>
                    <vim:id>TSM-SSH</vim:id>
                  </vim:StartService>
                </soapenv:Body>
              </soapenv:Envelope>
            timeout: 30
          delegate_to: localhost
          vars:
            ansible_connection: local
          when: vmware_session is defined
          register: ssh_start
          
        - name: Set SSH service policy to 'on'
          uri:
            url: "https://{{ target_host }}/sdk"
            method: POST
            validate_certs: no
            headers:
              Content-Type: "text/xml; charset=utf-8"
              SOAPAction: "urn:vim25/8.0"
              Cookie: "vmware_soap_session={{ vmware_session }}"
            body: |
              <?xml version="1.0" encoding="UTF-8"?>
              <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                xmlns:vim="urn:vim25">
                <soapenv:Body>
                  <vim:UpdateServicePolicy>
                    <vim:_this type="HostServiceSystem">hostServiceSystem</vim:_this>
                    <vim:id>TSM-SSH</vim:id>
                    <vim:policy>on</vim:policy>
                  </vim:UpdateServicePolicy>
                </soapenv:Body>
              </soapenv:Envelope>
            timeout: 30
          delegate_to: localhost
          vars:
            ansible_connection: local
          when: vmware_session is defined
          
        - name: Wait for SSH to become available
          wait_for:
            host: "{{ target_host }}"
            port: 22
            state: started
            delay: 5
            timeout: 60
          delegate_to: localhost
          vars:
            ansible_connection: local
          register: ssh_wait
          
        - name: Mark SSH as enabled by automation
          set_fact:
            ssh_was_enabled_by_automation: true
          when: ssh_wait is success
          
      rescue:
        - name: SSH enablement failed
          debug:
            msg: "SSH auto-enable failed. Assuming SSH is already enabled."
            
    # =========================================================================
    # SECTION 2: PRE-CHECK VALIDATION
    # =========================================================================
    - name: "2.1: Run Pre-check Validations"
      vars:
        ansible_connection: ssh
        ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
        ansible_user: "{{ esxi_username }}"
        ansible_password: "{{ esxi_password }}"
      block:
        - name: Test SSH connectivity
          wait_for_connection:
            timeout: 30
          register: ssh_connectivity
          
        - name: Get ESXi version
          raw: vmware -v
          register: esxi_version
          
        - name: Get ESXi build number
          raw: vmware -v | grep -o 'build-[0-9]*' | cut -d'-' -f2
          register: current_build
          
        - name: Check all datastores
          raw: |
            echo "=== Datastore Analysis ==="
            for DS in /vmfs/volumes/*; do
              if [ -d "$DS" ] && [[ "$DS" == *"datastore"* || -f "$DS/.vmfs" ]]; then
                DS_NAME=$(basename "$DS")
                TOTAL=$(df -B G "$DS" 2>/dev/null | tail -1 | awk '{print $2}' | sed 's/G//')
                FREE=$(df -B G "$DS" 2>/dev/null | tail -1 | awk '{print $4}' | sed 's/G//')
                PERCENT=$(df "$DS" 2>/dev/null | tail -1 | awk '{print $5}' | sed 's/%//')
                
                if [ ! -z "$FREE" ]; then
                  echo "DATASTORE:${DS_NAME}:${DS}:${TOTAL}:${FREE}:${PERCENT}"
                fi
              fi
            done | grep "^DATASTORE:"
          register: datastore_analysis
          
        - name: Check VM inventory
          raw: |
            echo "=== VM Inventory ==="
            TOTAL=0
            POWERED_ON=0
            VM_LIST=""
            
            for VMID in $(vim-cmd vmsvc/getallvms 2>/dev/null | tail -n +2 | awk '{print $1}'); do
              TOTAL=$((TOTAL + 1))
              VM_NAME=$(vim-cmd vmsvc/get.summary $VMID 2>/dev/null | grep -E "name = " | cut -d'"' -f2)
              VM_STATE=$(vim-cmd vmsvc/power.getstate $VMID 2>/dev/null | tail -1)
              
              if echo "$VM_STATE" | grep -q "Powered on"; then
                POWERED_ON=$((POWERED_ON + 1))
                VM_LIST="${VM_LIST}${VM_NAME}:on,"
              else
                VM_LIST="${VM_LIST}${VM_NAME}:off,"
              fi
            done
            
            echo "VMCOUNT:${TOTAL}:${POWERED_ON}"
            echo "VMLIST:${VM_LIST}"
          register: vm_inventory
          
        - name: Check system health
          raw: |
            echo "=== System Health ==="
            # CPU info
            CPU_MODEL=$(esxcli hardware cpu global get 2>/dev/null | grep "CPU Model" | cut -d: -f2 | xargs)
            CPU_CORES=$(esxcli hardware cpu global get 2>/dev/null | grep "CPU Cores" | cut -d: -f2 | xargs)
            
            # Memory info
            MEM_TOTAL=$(esxcli hardware memory get 2>/dev/null | grep "Physical Memory" | cut -d: -f2 | xargs)
            
            # Maintenance mode
            MM_STATUS=$(esxcli system maintenanceMode get 2>/dev/null)
            
            # Network adapters
            VMNIC_COUNT=$(esxcli network nic list 2>/dev/null | tail -n +2 | wc -l)
            
            echo "CPU:${CPU_MODEL}"
            echo "CORES:${CPU_CORES}"
            echo "MEMORY:${MEM_TOTAL}"
            echo "MAINTENANCE:${MM_STATUS}"
            echo "NICS:${VMNIC_COUNT}"
          register: system_health
          
        - name: Check for existing patches
          raw: |
            if [ -f "/vmfs/volumes/*/patches/{{ patch_file }}" ]; then
              PATCH_PATH=$(find /vmfs/volumes -name "{{ patch_file }}" 2>/dev/null | head -1)
              PATCH_SIZE=$(ls -lh "$PATCH_PATH" 2>/dev/null | awk '{print $5}')
              echo "PATCH_EXISTS:${PATCH_PATH}:${PATCH_SIZE}"
            else
              echo "PATCH_EXISTS:none:0"
            fi
          register: patch_check
          
    # =========================================================================
    # SECTION 3: PARSE AND ANALYZE RESULTS
    # =========================================================================
    - name: "3.1: Parse Pre-check Results"
      set_fact:
        current_build_number: "{{ current_build.stdout | trim }}"
        needs_patching: "{{ (current_build.stdout | trim | int) < (target_build | int) }}"
        
        # Parse datastore with most free space
        best_datastore: >-
          {%- set datastores = [] -%}
          {%- for line in datastore_analysis.stdout_lines -%}
            {%- if line.startswith('DATASTORE:') -%}
              {%- set parts = line.split(':') -%}
              {%- set _ = datastores.append({'name': parts[1], 'path': parts[2], 'total': parts[3]|int, 'free': parts[4]|int, 'used_percent': parts[5]|int}) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ datastores | sort(attribute='free', reverse=true) | first | default({'name': 'none', 'path': '/tmp', 'free': 0}) }}
        
        # Parse VM counts
        vm_stats: >-
          {%- set result = {'total': 0, 'powered_on': 0} -%}
          {%- for line in vm_inventory.stdout_lines -%}
            {%- if line.startswith('VMCOUNT:') -%}
              {%- set parts = line.split(':') -%}
              {%- set _ = result.update({'total': parts[1]|int, 'powered_on': parts[2]|int}) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ result }}
        
        # System health
        is_maintenance_mode: "{{ 'Enabled' in system_health.stdout }}"
        
        # Patch existence
        patch_already_staged: "{{ 'none' not in patch_check.stdout }}"
        
    - name: "3.2: Determine Pre-check Status"
      set_fact:
        precheck_passed: >-
          {{ 
            (ssh_connectivity is success) and
            (best_datastore.free | int >= minimum_space_gb | int) and
            (not is_maintenance_mode or vm_stats.powered_on == 0)
          }}
        
        precheck_warnings: >-
          {%- set warnings = [] -%}
          {%- if best_datastore.free | int < minimum_space_gb | int -%}
            {%- set _ = warnings.append('Insufficient space: ' + best_datastore.free|string + 'GB available, ' + minimum_space_gb|string + 'GB required') -%}
          {%- endif -%}
          {%- if vm_stats.powered_on > 0 -%}
            {%- set _ = warnings.append(vm_stats.powered_on|string + ' VMs are powered on') -%}
          {%- endif -%}
          {%- if is_maintenance_mode -%}
            {%- set _ = warnings.append('Host is already in maintenance mode') -%}
          {%- endif -%}
          {%- if not needs_patching -%}
            {%- set _ = warnings.append('Host already at target build ' + target_build) -%}
          {%- endif -%}
          {{ warnings | join(', ') if warnings else 'None' }}
          
    # =========================================================================
    # SECTION 4: REPORTING
    # =========================================================================
    - name: "4.1: Send Dynatrace Metrics"
      when: dynatrace_enabled | bool and dynatrace_token is defined
      uri:
        url: "{{ dynatrace_url }}/api/v2/metrics/ingest"
        method: POST
        headers:
          Authorization: "Api-Token {{ dynatrace_token }}"
          Content-Type: "text/plain; charset=utf-8"
        body: |
          esxi.precheck.status,host={{ inventory_hostname }} {{ 1 if precheck_passed else 0 }} {{ precheck_timestamp }}
          esxi.precheck.build,host={{ inventory_hostname }} {{ current_build_number }} {{ precheck_timestamp }}
          esxi.precheck.space_gb,host={{ inventory_hostname }} {{ best_datastore.free }} {{ precheck_timestamp }}
          esxi.precheck.vms_total,host={{ inventory_hostname }} {{ vm_stats.total }} {{ precheck_timestamp }}
          esxi.precheck.vms_powered,host={{ inventory_hostname }} {{ vm_stats.powered_on }} {{ precheck_timestamp }}
          esxi.precheck.needs_patch,host={{ inventory_hostname }} {{ 1 if needs_patching else 0 }} {{ precheck_timestamp }}
        status_code: [200, 201, 202, 204]
      delegate_to: localhost
      vars:
        ansible_connection: local
      ignore_errors: yes
      
    - name: "4.2: Display Pre-check Summary"
      debug:
        msg:
          - "============================================================"
          - "STAGE 1: PRE-CHECK SUMMARY"
          - "============================================================"
          - "Host: {{ inventory_hostname }} ({{ target_host }})"
          - "------------------------------------------------------------"
          - "SYSTEM INFO:"
          - "  ESXi Version: {{ esxi_version.stdout | trim }}"
          - "  Current Build: {{ current_build_number }}"
          - "  Target Build: {{ target_build }}"
          - "  Needs Patching: {{ 'YES ⚠️' if needs_patching else 'NO ✓' }}"
          - "  Maintenance Mode: {{ 'YES' if is_maintenance_mode else 'NO' }}"
          - "------------------------------------------------------------"
          - "STORAGE:"
          - "  Best Datastore: {{ best_datastore.name }}"
          - "  Path: {{ best_datastore.path }}"
          - "  Available Space: {{ best_datastore.free }}GB"
          - "  Required Space: {{ minimum_space_gb }}GB"
          - "  Space Check: {{ 'PASS ✓' if best_datastore.free|int >= minimum_space_gb|int else 'FAIL ✗' }}"
          - "  Patch Staged: {{ 'YES' if patch_already_staged else 'NO' }}"
          - "------------------------------------------------------------"
          - "VIRTUAL MACHINES:"
          - "  Total VMs: {{ vm_stats.total }}"
          - "  Powered On: {{ vm_stats.powered_on }}"
          - "------------------------------------------------------------"
          - "PRE-CHECK STATUS: {{ 'PASSED ✓' if precheck_passed else 'FAILED ✗' }}"
          - "WARNINGS: {{ precheck_warnings }}"
          - "SSH Auto-Enabled: {{ 'YES' if ssh_was_enabled_by_automation else 'NO' }}"
          - "============================================================"
          
    - name: "4.3: Save Pre-check Results"
      set_stats:
        data:
          stage1_status: "{{ 'passed' if precheck_passed else 'failed' }}"
          needs_patching: "{{ needs_patching }}"
          current_build: "{{ current_build_number }}"
          target_build: "{{ target_build }}"
          selected_datastore: "{{ best_datastore.path }}"
          available_space_gb: "{{ best_datastore.free }}"
          vm_count_total: "{{ vm_stats.total }}"
          vm_count_powered: "{{ vm_stats.powered_on }}"
          ssh_enabled: "{{ ssh_was_enabled_by_automation }}"
          warnings: "{{ precheck_warnings }}"
          
    - name: "4.4: Disable SSH if Needed"
      when:
        - not keep_ssh_enabled | bool
        - ssh_was_enabled_by_automation | bool
      block:
        - name: Stop SSH service
          uri:
            url: "https://{{ target_host }}/sdk"
            method: POST
            validate_certs: no
            headers:
              Content-Type: "text/xml; charset=utf-8"
              SOAPAction: "urn:vim25/8.0"
              Cookie: "vmware_soap_session={{ vmware_session }}"
            body: |
              <?xml version="1.0" encoding="UTF-8"?>
              <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                xmlns:vim="urn:vim25">
                <soapenv:Body>
                  <vim:StopService>
                    <vim:_this type="HostServiceSystem">hostServiceSystem</vim:_this>
                    <vim:id>TSM-SSH</vim:id>
                  </vim:StopService>
                </soapenv:Body>
              </soapenv:Envelope>
            timeout: 30
          delegate_to: localhost
          vars:
            ansible_connection: local
            
    - name: "4.5: Fail if Pre-check Failed"
      fail:
        msg: |
          Pre-check FAILED for {{ inventory_hostname }}
          Warnings: {{ precheck_warnings }}
      when:
        - not precheck_passed
        - enforce_precheck | default(true) | bool
